<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何向别人介绍DDD]]></title>
    <url>%2F2018%2F04%2F24%2FArt-2018-2018-04-24-sell-DDD%2F</url>
    <content type="text"><![CDATA[近日有人问过我一个问题,如何给人介绍DDD(领域驱动设计)? 我答得不是很好,因为我从未的考虑过在没PPT的情况下,该如何有效地让人短时间内理解DDD的理念. 是阿,这么复杂的理念,该如何让人在短时间内建立印象呢? DDD有学习曲线的DDD是有学习曲线的,而且可能很陡. 它是对传统的以数据为中心建模方式的反思结果,是关于”OO Done Right”. 如果你的业务很简单,CURD就能满足的话,那没必要改造成的DDD的方式,但这并不妨碍你去了解一下什么是DDD. DDD不适合我们?Q: DDD不适合我们这样的公司,我们的软件开发都是交给外包团队来做的,通用语言没必要. 这个问题我答得不好,因为我在前面的介绍里漏掉了”通用语言”,我陷入了先介绍战术细节的泥潭之中了. 是的,战术部分不一定适合所有的场景,但是战略部分还是很值得一试的. 战术与战略战术是具体的,它是关于对象设计,程序架构,持久化策略等等. 战略是抽象的,关于问题领域分解,通用语言,上下文映射关系等等. 通过对问题域的拆分,才能分辨出那些是核心域,那些是子域(包括支持子域和普通子域).通常来说,子域部分适合外包出去,核心域处于自己控制的范围较好. 通用语言的最大作用是降低不同团队之间的沟通成本,如果业务逻辑沟通不顺畅的话,很大概率上会带来项目计划的延期. 上下文映射关系反映的是团队之间的关系,也适用己方与外包团队的关系.认清正确的团队关系,能够更好的做系统架构上的决策. 反思思考问题的时候,要从大局出发,先战略再战术.]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件风暴工作坊初体验]]></title>
    <url>%2F2018%2F03%2F29%2FArt-2018-2018-03-29-event-storming%2F</url>
    <content type="text"><![CDATA[工作坊初体验 本月有幸参加DDD中国在广州举办的【微服务时代的领域驱动设计实战工作坊——广州站】，在参加之前就好奇，什么叫做工作坊？一天的活动下来之后，对工作坊的工作方式有了初步的体验，我尝试把它写下来。 什么是DDD？ 实战工作坊的核心理念是基于DDD（领域驱动设计）的，它本身并不是什么新理念， 早在十几年前由Eric Evans在《领域驱动设计》提出来。 软件设计发展历程中，首先是面向过程设计、然后再是面向对象设计（OO）。 简单的业务用面向过程的方式实现是没毛病的，但是遇到复杂的业务逻辑的时候，面向过程就有心无力了。 所以有了面向对象的设计，封装、继承、多态是OO的基本理念，大多数实现OO的语言都有的特性。 但是，知道什么是OO并不等于知道如何去做到OO，有没有什么套路让我们更加有效去实现一个OO的设计呢？ 答案就是DDD，DDD给予我们设计OO的方向，它解决的核心问题是业务架构与系统架构如何去保持一致。 领域驱动设计是一种设计方法, 试图解决的问题是软件的难以理解, 难以演化. 领域驱动设计试图 分离技术实现的复杂性, 用围绕业务概念来构建领域模型的方式来控制业务的复杂性。 DDD三原则 关注核心域 通过协助迭代探索模型 在同个限界上下文内使用通用语言 什么是事件风暴？实现DDD的方式也是多样的，事件风暴是其中的一种。它是由Alberto Brandolini所创建的一种专注于事件的设计过程。 事件风暴就是把所有的关键参与者都召集到一个很宽敞的屋子里来开会，并且使用便利贴来描述系统中发生的事情。 一张桔黄色的便利贴代表一个领域事件，在上面用一句过去时的话描述曾经发生过什么事情。 为了让自己关注最终目标，经常从结束时的最后一个事件开始，然后把第一个事件加上来，就有了一个从开始到结束的完整时间表。 工作坊给了我们一个贴近实际的业务场景，让我们按照事件风暴的实践步骤，从事件的角度，一步步去设计业务模型。经历过一天的切身体会，事件风暴是一种简单高效的建模方式，它没有UML那么复杂的条条框框，也能让非技术的关键业务角色参与进来核心架构的设计过程之中，从而让系统架构和业务架构高度一致。 事件风暴实践步骤 事件风暴的实践步骤主要有以下4点： 事件风暴 事件风暴的概念是来自于头脑风暴 首先需要把项目相关的所有关键参与者都召集到一个很宽敞的屋子里来开会。 业务专家先介绍核心业务与主要的业务场景，参与者参与讨论。 参与者按照自己对业务的理解，寻找业务过程中发生过有业务价值的事件，写在橙色的即时贴上。 （一个事件一个即时贴，采用 “xx已xx”的格式，比如”订单已创建” ） 每个参与者把自己的事件贴到白版上，最后按照事件时间顺序从左到右排序，去重。 命令风暴 事件是由某些决策产生的命令触发的。决策的类型有3种：用户指令、外部系统触发、定时任务。 从已发现的事件里倒推出相关的命令，把发出命令的决策写在蓝色的即时贴上。 决策贴在事件的左边，有些决策可能触发多个事件。 从决策出发，发现决策参考的读模型（紫色即时贴）、和触发决策的角色（黄色即时贴）。 整个流程下来，基本上所有关键的业务事件、角色、决策都可视化了。 寻找聚合 从命令风暴的结果里寻找聚合（用大的黄色即时贴），保留相关的决策和事件。 划出边界，找出限界上下文。上下文之间建立地图，用U／D标出上游／下游的关系。 持续探索 持续讨论，演进上下文映射图。 从上下文出发，自然而然的做到微服务划分。 结论通过工作坊的方式，可以产生很多有价值的领域模型。 微服务如何划分一直是个难点，从事件风暴出发直到画出限界上下文，服务划分自然而然。 从事件的模型出发，去实现EDA和CQRS架构也有了很好的起步了。 Ref http://www.infoq.com/cn/news/2016/07/event-storming-ddd http://www.imspender.com/articles/bu-yong-ddd-na-ni-de-wei-fu-wu]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[One Issue Cause By Id]]></title>
    <url>%2F2018%2F02%2F27%2FTech-2018-2018-02-27-One-Issue-Cause-By-Id%2F</url>
    <content type="text"><![CDATA[一个ID引起的血案一个少见的丢单问题最近遇到一个少见的丢单问题: 2个订单在同一秒下单,产生的订单ID居然是一样的! 经过一番查找,问题的原因在生产ID的工具类实现算法有漏洞,关键方法源码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class LongId &#123; ... private Set&lt;Long&gt; recentRandoms = new HashSet&lt;Long&gt;(5000); ... /** * Generates a Twitter Snowflake compatible id utilizing randomness for the right most 22 bits and * the Twitter standard EPOCH * * @return long */ synchronized public long generate() &#123; long currentTimestamp = System.currentTimeMillis(); while (lastTimestamp &gt; currentTimestamp) &#123; // Clock is running backwards so wait until it isn't currentTimestamp = System.currentTimeMillis(); &#125; if (currentTimestamp &lt; EPOCH || currentTimestamp &gt; MAX_SIGNED_LONG) &#123; // The current time cannot be less than the EPOCH throw new RuntimeException("Invalid System Clock was " + new Date(currentTimestamp)); &#125; final long customTimestamp = currentTimestamp - EPOCH; final long shiftedTimestamp = customTimestamp &lt;&lt; TIME_SHIFT; long random = nextRandomPart(); if (lastTimestamp != currentTimestamp) &#123; // timestamp has advanced so reset it and clear the previous cache lastTimestamp = currentTimestamp; recentRandoms.clear(); &#125; else &#123; // Same timestamp as previous keep generating randoms till new is found while (recentRandoms.contains(random)) &#123; random = nextRandomPart(); &#125; &#125; recentRandoms.add(random); return shiftedTimestamp | random; &#125; private long nextRandomPart() &#123; return ThreadLocalRandom.current().nextLong() &gt;&gt;&gt; RANDOM_SHIFT; &#125;&#125; 这个方法是参考Twitter Snowflake(一个来自Twitter的分布式ID算法)的java实现. 确定问题的方法是重现问题,幸好这个工具类是孤独的,:) ,所以写个单元测试还是比较简单的. 测试代码如下,简单来说就是模拟同一时间有多少生产ID的并发请求,当出现重复ID的时候测试失败. 12345678910111213141516171819202122232425262728293031public class LongIdTest &#123; @Test public void testId_100() throws Throwable &#123; paralletTestThread(getMockTimes(100), this::getId); &#125; private void paralletTestThread(List&lt;Integer&gt; list, Supplier&lt;Long&gt; method) &#123; Map idMap = new ConcurrentHashMap(); list.parallelStream().forEach(t -&gt; &#123; Long id = method.get(); assertNull(id.toString(), idMap.get(id)); idMap.put(id, System.nanoTime()); &#125;); &#125; private long getId() &#123; return LongId.get(); &#125; private List&lt;Integer&gt; getMockTimes(int maxTime) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; maxTime; i++) list.add(i); return list; &#125;&#125; 测试结果,当并发次数为1000次的时候,很容易重现问题. 虽然源码通过 shiftedTimestamp | random 来保证每次产生的ID是不一样的,但是实验结果表面尽管shiftedTimestamp和random每次都是不一样的, 但是与运算的结果却可能是一样的,知道问题原因就好处理了. 重新写了一个新的ID生产算法工具类如下,在规定的时间内缓存生产的ID,如果出现重复就重新生成. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LongIdThreadSafety &#123; ... private Set&lt;Long&gt; recentRandoms = ConcurrentHashMap.&lt;Long&gt;newKeySet(); ... synchronized public long generate() &#123; long currentTimestamp = System.currentTimeMillis(); while (lastTimestamp.get() &gt; currentTimestamp) &#123; // Clock is running backwards so wait until it isn't currentTimestamp = System.currentTimeMillis(); &#125; if (lastTimestamp.get() != currentTimestamp) &#123; // timestamp has advanced so reset it and clear the previous cache lastTimestamp.lazySet(currentTimestamp); &#125; if (lastTimestamp.get() - currentTimestamp &gt; MAX_TIME_MILLIS_CHANGE) &#123; recentRandoms.clear(); &#125; if (currentTimestamp &lt; EPOCH || currentTimestamp &gt; MAX_SIGNED_LONG) &#123; // The current time cannot be less than the EPOCH throw new RuntimeException("Invalid System Clock was " + new Date(currentTimestamp)); &#125; final long customTimestamp = currentTimestamp - EPOCH; final long shiftedTimestamp = customTimestamp &lt;&lt; TIME_SHIFT; AtomicReference&lt;Long&gt; result = new AtomicReference&lt;&gt;(null); AtomicReference&lt;Long&gt; random = new AtomicReference&lt;&gt;(nextRandomPart()); makeUniqueId(shiftedTimestamp, result, random); // System.out.println(result.get() + " is build by " + shiftedTimestamp + " and " + random.get() // + " on time " + new Date(currentTimestamp)); return result.get(); &#125; private void makeUniqueId(long shiftedTimestamp, AtomicReference&lt;Long&gt; result, AtomicReference&lt;Long&gt; random) &#123; result.set(shiftedTimestamp | random.get()); while (recentRandoms.contains(result.get())) &#123; random.set(nextRandomPart()); result.set(shiftedTimestamp | random.get()); &#125; if (!recentRandoms.contains(result.get())) &#123; recentRandoms.add(result.get()); &#125; &#125; private long nextRandomPart() &#123; return ThreadLocalRandom.current().nextLong() &gt;&gt;&gt; RANDOM_SHIFT; &#125;&#125; 同样用相同的测试代码来测试,测试1000,10000次都通过测试,Issue Fixed ! 1234567891011121314@Testpublic void testIdThreadSafety_1000()throws Throwable&#123; paralletTestThread(getMockTimes(1000),this::getIdThreadSafety); &#125;@Testpublic void testIdThreadSafety_10000()throws Throwable&#123; paralletTestThread(getMockTimes(10000),this::getIdThreadSafety); &#125;private long getIdThreadSafety()&#123; return LongIdThreadSafety.get(); &#125;]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Resin 3 With JavaEE8]]></title>
    <url>%2F2016%2F11%2F09%2FTech-2016-2016-11-09-resinWithJavaEE8%2F</url>
    <content type="text"><![CDATA[Resin 3 With JavaEE 8 Resin 3 本身只支持JavaEE 6，要让它能允许JavaEE 8的应用是需要踩一些坑的。 ：） NoSuchMethodError: javax.persistence.Table.indexes()[Ljavax/persistence/IndexResin 3 支持JavaEE 6的规范， 对应的JPA版本是JPA 2， 而Hibernate 4.3开始使用JPA 2.1。 运行时的会默认用resin/lib下的JPA 2，因为JPA 2的@Table不支持indexes属性，所以初始化Hibernate 4.3以上版本的时候会抛出javax.persistence.Table.indexes()错误。 解决方案 简单粗暴的做法，就是禁止掉resin/lib/jpa-15.jar， 重命名成jpa-15.jar_bak之类，应用在运行的时候会用回Hibernate本身自带的JPA版本。 Unsupported major.minor version 52.0某些Resin 3的运行环境里会默认使用较低的JDK版本，比如Open JDK 7之类，所以运行JDK8编译过的类的时候会抛出Unsupported major.minor version。查看resin的启动脚本/bin/httpd.sh 123456789101112131415...if test -n "$&#123;JAVA_HOME&#125;"; then if test -z "$&#123;JAVA_EXE&#125;"; then JAVA_EXE=$JAVA_HOME/bin/java fifiif test -z "$&#123;JAVA_EXE&#125;"; then JAVA_EXE=java fi...exec $JAVA_EXE -jar $&#123;RESIN_HOME&#125;/lib/resin.jar $* 一般情况下设置${JAVA_HOME} 的环境变量为JDK8就好，我遇到一个比较坑的情况是Jenkins远程调用的时候，${JAVA_HOME}被变成了JDK7. 解决方案 在启动脚本里指定指定${JAVA\_HOME}，并且export JAVA_HOME到环境变量 Ref＊ http://stackoverflow.com/questions/20734540/nosuchmethoderror-in-javax-persistence-table-indexesljavax-persistence-index]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC]]></title>
    <url>%2F2016%2F09%2F19%2FTech-2016-2016-09-19-SpringMVC%2F</url>
    <content type="text"><![CDATA[Spring MVCMVC模型有很多种实现，Spring MVC是其中较经典的一种。 Spring MVC is a Servlet本质上，Spring MVC是一个Servlet，它需要一个Servlet容器（Tomcat、WAS等）。 它提供了3个层次的Servlet： HttpServletBean直接继承Java的HttpServlet，将Servlet中配置的参数设置到对应的属性中。 FrameworkServlet初始化了WebApplication－Context和对应的组件。 DispatherServletSpring MVC最核心的类，入口方法是doService，但具体的处理在doDispath里实现，doService在调用doDispatch的前后做了相应的请求处理。 doDispatchdoDispatch的主要任务有4个： 根据request找到Hanlder 根据Handler找到对应的HanlderAdapter 用HanlderAdapter处理Handler 调用processDispathResult方法处理结果，并找到View渲染给用户。 A Http Request life cycle一个Http请求到MVC的处理的主要步骤如下图： 参考文献 《看透Spring MVC》]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Concurrency]]></title>
    <url>%2F2016%2F09%2F13%2FTech-2016-2016-09-13-JavaConcurrency%2F</url>
    <content type="text"><![CDATA[Java 并发一谈起并发，就离开不了同步机制、线程安全。 同步机制Java常用的同步机制有： volatile , synchronized volatile用volatile修饰的变量就拥有2个特性： 可见性、禁止指令重排序优化。 可见性保证变量对所有线程的的可见性，普通变量无法做到这点，只能通过主内存来传递。 Java里的运算并非原子操作，导致volatile变量的运算在并发下也是不安全的。 从内存可见性的角度，读取volatile变量等于进入同步代码块，写入volatile等于推出同步代码块。 禁止指令重排序优化指令重排序是指CPU允许多条指令不按程序规定的顺序分开发送给各相应电路单元处理。volatile能保证处理器不发生乱序执行。 synchronizedsynchronized是最基本的互斥同步手段。 synchronized关键字经过编译之后，会在同步块前后形成monitorenter 和monitorexit 2个字节码指令。根据虚拟机规范，执行monitorenter会尝试加锁， 执行monitorexit会释放锁。 synchronized中的锁是非公平的，java.util.concurrent包下的ReentrantLock也有类似功能，但可以通过构造函数来实现公平锁。 volatile vs. synchronized|———–+————||volatile | synchronized ||:———|——-:||最轻量级 | 较重（悲观并发策略）||线程不安全 | 线程安全|{: rules=”groups”} 线程安全当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 无状态对象一定是线程安全的。 不可变对象一定是线程安全的。 Immutable对象一定是线程安全的，final关键字可以保证它是不变的。 java.util.concurrent包下的对象也都是线程安全的。 线程安全 线程不安全 Vector、CopyOnWriteArrayList ArrayList HashTable、ConcurrentHashMap HashMap {: rules=”groups”} 参考文献 《深入浅出Java虚拟机》 《Java并发编程实战》]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Memory Model]]></title>
    <url>%2F2016%2F09%2F12%2FTech-2016-2016-09-12-JavaMemModel%2F</url>
    <content type="text"><![CDATA[Java 内存模型Java不像C＋＋由程序员直接管理内存，而是由虚拟机内存管理机制管理。 以JDK1.7为例子，内存模型如下： 内存模型 程序计数器 （Program Counter Register） Java虚拟机栈 （Java Virtual Machine Stacks） 本地方法栈 （Native Method Stack） Java堆 （Java Heap） 方法区 （Method Area） 运行时常量池 （Runtime Constant Pool） 直接内存 （Direct Memory） 程序计数器 （Program Counter Register）程序计数器是一块较小的线程私有的内存空间，用了记录正在执行的虚拟机字节码指令的地址。通过改变这个计数器的值来选取下一条字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依靠它来实现。 执行Native方法的时候，其值为空（Undefined）。 此内存区域是虚拟机规范唯一没有规定任何OutOfMemoryError的区域。 Java虚拟机栈 （Java Virtual Machine Stacks）Java虚拟机栈也是线程私有的内存空间，它的生命周期和线程一样。 它是描述Java方法执行的内存模型： 每个方法在执行的同时都会创建一个栈桢（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每个方法从调用到结束，就对应一个栈桢在虚拟机栈中入栈到出栈的过程。 本地方法栈 （Native Method Stack）本地方法栈 （Native Method Stack）与Java虚拟机栈的作用非常相似，其区别是： 虚拟机栈为Java方法服务，本地方法栈为虚拟机用到的Native方法服务。 Java堆 （Java Heap）Java堆是所有线程共享的内存区域，是最大的一块。 其唯一目的就是存放对象实例，也是GC管理的主要区域。 从内存回收的角度，还可以细分为： 新生代（Young Generation）和老年代（Old Generation）等。 年轻代为创建的短期对象，失效之后很快会被垃圾回收。该区又被划分为Eden和两个Survivor区域。 老年代存放的多数为存活时间较长的对象。 垃圾回收GC分为两种Minor GC、Full GC； Minor GC发生频繁，但是仅针对年轻代。 Full GC 触发条件 调用System.gc() 老年代空间不足 永久代空间不足 空间分配担保失败 Cocurrent mode failure 方法区 （Method Area）方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 虽然和Java堆一样是各个线程共享的内存区域，却有一个别名 Non－Heap （非堆） 在HotSpot虚拟机上“方法区”被更多人称为“永久代” （Permanent Generation），但对其它虚拟机并不存在这样的概念。 而且在JDK8里，永久代也被Metaspace所替代，位置也移到native memory里。 这样做的好处在于：简化GC的算法，full gc的时候更高效率。 运行时常量池 （Runtime Constant Pool）运行时常量池 是方法区的一部分，用于存储编译期生成的各种字面量和符号引用，在类加载后进入方法区的运行时常量池中。 直接内存 （Direct Memory）直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。它属于堆外内存，受到本机内存大小、寻址空间的限制。 参考文献 《深入浅出Java虚拟机》 JVM堆内存监测的一种方式，性能调优依旧任重道远]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM Class Loader]]></title>
    <url>%2F2016%2F09%2F09%2FTech-2016-2016-09-09-jvm-classloader%2F</url>
    <content type="text"><![CDATA[浅谈类加载机制本文以JDK1.7为例子，简单地介绍一下类加载的原理。 类生命周期说起类加载，就不得不先谈一下类的生命周期。主要有以下7个阶段： 加载（Loading） 连接 （Linking） 验证 （Verification） 准备 （Preparation） 解析 （Resolution） 初始化 （Initialization） 使用 （Using） 卸载 （Unloading） 验证、准备、解析3部分统称连接。 加载在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口。 初始化时机虚拟机规范严格规定 有且只有 5种情况必须立即对类进行初始化： 使用关键字new实例化一个对象、读取或设置静态字段的时候 使用java.lang.reflect包进行反射调用的时候 初始化一个子类的时候，如果其父类为初始化，需要先触发。 虚拟机启动，用户指定的一个包含main（）方法的执行主类的时候。 使用动态语言，一个java.lang.invoke.MethodHandle实例，最后解析结果”REF_getStatic, REF_putStatic,REF_invokeStatic”句柄所对应的未进行过初始化的类。 类加载器类加载器的主要作用：就是实现“通过一个类的全限定名来获取定义此类的二进制字节流” 这个动作的。 类加载器主要有3种： 启动类加载器 （Bootstrap ClassLoader）: C＋＋实现，负责加载&lt;JAVA_HOME&gt;\lib目录下（或-Xbootclasspath指定路径）的类库。无法被Java程序直接引用。 扩张类加载器 （Extension ClassLoader）: sun.misc.Launcher$ExtClassLoader实现，负责加载&lt;JAVA_HOME&gt;\lib\ext目录下(或java.ext.dirs指定路径)的类库。开发者可以直接使用。 应用程序类加载器（Application ClassLoader）: sun.misc.Launcher$ClassLoader实现，负责加载用户类路径（ClassPath）下的类库。开发者可以直接使用。 双亲委托模型 （Parents Delegation Model） 除了顶层启动类加载器之外，其余的类加载器都有自己的父类加载器，他们的父子关系一般不会以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用。 双亲委托模型的原理是： 当收到类加载请求，不会自己去加载，而是委托给父类加载器。 每一层都一样，最终都到达顶层的启动类加载器中。 只有父加载器无法加载，子加载器才会尝试自己加载。 好处： Java类有顶级优先级，保证了Java程序的稳定运作。 （例如rt.jar里的java.lang.Object,无论哪一个类加载器加载，最终都会委派给启动类加载器加载） 双亲委托模型并不是强制性的约束模型，某些情况下也有例外： JDK1.2之后才引入“双亲委托” ，向前兼容JDK1.0的用户自定义ClassLoader。 涉及SPI的加载方式： JNDI、JDBC、JCE、JAXB、JBI等。 OSGi环境下，类加载器不再是双亲委托模型的树状结构，而是更加复杂的网状结构。 参考文献 《深入浅出Java虚拟机》]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Four-quadrant diagram and ROI]]></title>
    <url>%2F2016%2F09%2F02%2FArt-2016-2016-09-02-AgileTest%2F</url>
    <content type="text"><![CDATA[四象限图与ROI读完这本《敏捷软件测试》，印象最深刻莫过于测试的象限图。 四象限图 从象限图里，可以知道测试的类型有多少种，什么时候应该执行那种测试。什么样的时候应该自动化，什么样的时候不应该测试。 ROI （投资回报率）衡量某种测试是否值得去做自动化的关键指标就是ROI （投资回报率）。API接口和核心业务属于相对较稳定的部分，实现自动化测试的回报率也高。 自动化敏捷项目依赖于自动化，离开自动化的项目不能称之为敏捷项目。自动化单元测试的基石是TDD，离开TDD的方式去实现自动化单元测试，ROI也是低下的。 参考文献*《敏捷软件测试》]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NoSQL Distilled]]></title>
    <url>%2F2016%2F02%2F15%2FTech-2016-2016-02-15-NoDQLDistilled%2F</url>
    <content type="text"><![CDATA[NoSQL 精粹Martin Fowler和Pramond（《数据库重构》作者）联合出品的这本书，为了我们如何看待、使用NoSQL数据库，提供了一个很好的起点。 为什么要用NoSQL？关系型数据库有很多优势，但绝非完美。对开发者来说，最令他们失望的就是： 关系模型和内存中的数据结构存在差异，即 “阻抗失谐” 另外，关系型数据库在集群的环境中使用的成本较高，不适用于21世纪的互联网公司。NoSQL作为无模式、非关系数据库而出现，有效的解决以上问题。为关系型数据库做了有益的补充，让混合持久化成为了当今的趋势。 数据模型 NoSQL数据库的数据模型有2种：面向聚合的数据模型、面向复杂关系的数据模型。键值、文档、列族类型的NoSQL数据库都属于面向聚合的数据模型。而“图”数据库则是一个异类，它比关系型数据库更擅长处理复杂的关系，补充了关系型数据库的另外一个不足之处。 它们都是无模式的数据库，可以随意新增字段，然而用户在使用数据时，通常还是要遵循一套隐式模式。 面向聚合的数据库对于复杂查询的支持比不上关系型数据库，它通常是用不同的方式重组主聚合的数据，以计算出各种“物化视图”。计算过程一般通过“map－reduce”来实现。 分布式模型在不需要分布数据就能应对时，总应选用“单一服务器”方案。 数据分布的路径有2种：复制（replication）、分片（sharding） 。2者是“正交的” ，可单独使用，也可以结合使用。 由简至繁的顺序如下： 单一服务器 分片 主从复制 对等复制 分片把数据分部分存放在不同服务器中，以此实现横向扩张，这种技术就叫“分片”。分片同时提高来读取和写入的效率，但也有可能降低数据库的错误恢复能力。 主从复制主持复制通常是经过“投票”的方法来选定一个“主节点”，“主节点”负责写入数据，通过复制的方式把数据同步到“从节点”，“从节点”复制数据的读取。 主从复制适合需要频繁读取数据的情况，它增强来读取操作的故障恢复能力。但其缺点是，在数据同步的过程中，容易带来数据的不一致性. 对等复制对等复制没有“主节点”的概念，所有的节点对等的写入和读取。但它也存在数据的不一致性的问题。 版本戳版本戳可以由计数器、GUID、内容哈希码、时间戳来实现，或者组合其中几种来实现。通过版本戳可以有效的检测并发冲突问题。 映射-从简map-reduce是一种集群上执行并发计算的模式 “映射”任务从聚合中读取数据，将之缩减为相关键值对。“从简”任务将“映射”任务生成的许多相同关键字的值简化为一个输出值。它们之间可以通过“管道”的方式来组合，通过“物化视图”来存储招的计算结果。 键值数据库键值数据库（key－value）是一张简单的哈希表，所有数据库访问都通过主键来操作。 流行的键值数据库有：Riak，Redis、Memcached等。。 适用场合 session信息 用户配置信息 购物车数据 不适用场合 数据间关系 含有多项操作的事务 查询数据 操作关键字集合 文档数据库文档数据库以“文档”为主要概念，存储格式可以是XML、JSON、BSON等。 流行的文档数据库有： MongoDB、CouchDB等 它有一个键值数据库没有的好处： 可以直接查询文档中的数据，不需要先根据关键字获取整个文档。 适用场合 事件记录 CMS与Blog 网站分析与实时分析 电子商务 不适用场合 包含多项操作的复杂事务 查询持续变化的聚合结构 列族数据库列族数据库可以存储关键字及其映射值，并且可以把值分成多个列族，让每个列族代表一张数据映射表。 流行的列族数据库有： Cassandra、HBase等 适用场合 事件记录 CMS与Blog 计数器 限期使用 不适用场合 查询模式多变的场景 图数据库图数据库可以存放实体及实体间的关系，实体也叫“节点”，它们之间的关系也叫“边”。 流行的图数据库有：Neo4J、HyperGraphDB 等 适用场合 互联数据 基于位置的服务 推荐引擎 不适用场合 属性多变的场景 混合持久化不同的数据库用来解决不同的问题，只用一种数据库引擎的时代已经过去。]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Building MicroService]]></title>
    <url>%2F2015%2F11%2F24%2FArt-2015-2015-11-24-buildingMicroService%2F</url>
    <content type="text"><![CDATA[构建微服务 微服务向来是我个人更倾向的一种架构风格，它具有更加开放的技术姿态。通过阅读这本《Building MicroService》，让我对微服务有了更深入的了解，同时也发现了它与DDD、CD是完美契合的。 康威定律任何设计系统的组织，最终产生的设计等同于组织之内、之间的沟通结构。系统架构的设计符合组织沟通结构取得的收益最大。 组织的架构最终决定系统的架构，如果你存在一个等级森严、层层架构的组织，那么，微服务就不一定适合你的组织。 什么是微服务？这个世界上既不存在银弹，也不会有免费的午餐。 微服务作为一个新兴的分布式系统架构，它解决了如何实现低耦合、高内聚的问题，同时也带来了很多分布系统特有的复杂性。 微服务是指：一些小而独立的服务联合起来一起工作。 那么，多小算小？ 给一个具体的代码行数是不靠谱的，不同的语言实现同样的功能，所需要的行数也是不同。一般来说，一个team花2周的时间就能实现的功能大小比较合适。 好处 技术多样性 容灾性 伸缩性 容易部署 与组织结构对应 组合性 可替换性 挑战 切分 部署 监控 安全 集成 （使用不同的技术栈来构建微服务） MicroService vs SOA微服务是一种特殊的SOA实现方式，就像XP ／ Scrum是敏捷开发的一种实现方式。 进化的架构构建微服务的过程中，架构师的角色更像是一个城市规划师，而不是一栋建筑的设计师。架构师需要制定对应的：战略目标、规则、以及实践方式。 有统一标准的监控、接口实现方式和安全措施。 集成服务集成理想的集成技术应该是： 避免破坏性的改变 保持API的技术无限性 让消费者简单使用服务 隐藏实现细节 共享数据库共享数据库的方式让数据更容易去共享，但对行为的共享没有任何帮助。 同步 vs 异步同步没什么好说的。 ：） 异步的交流方式有2种 ：request/response 或者 event-based request/response： 一问一答的方式比较传统，也可用于同步的方式。 event-based： 事件驱动,这种方式是基于事物状态的变化，能够高度的解耦。 RPC （Remote Procedure Calls）RPC的技术能让本地环境方便去调用外部接口，同时也具有较高的性能。 但是它也存在一些特有的问题： 技术耦合 本地调用不等于远程调用 易脆 一些RPC的机制，例如Java RMI，会严重地去依赖某个特定的平台，限制服务器和客户端所使用的技术。 RPC的核心理念是隐藏远程调用的复杂性，但是往往隐藏的过多，本地调用并不等于远程调用。 分布式系统的第一谬误， “网络是稳定的”。 任何RPC机制的最大问题在于，无法分开部署客户端和服务器端。如果你使用这项技术，未来的更新步骤是锁步的。 RESTREST是基于HTTP本身特性的架构风格，它有三种成熟度模型，详情请查看 Richardson Restful成熟度模型 DRYDRY原则更多的是：关于避免重复系统的行为和知识，而不是单单代码层面的重复。 实践原则 围绕业务内容建模多年来的工作经验告诉我们：基于业务边界划分的结构，要远比基于技术内容划分的结构稳定。 《领域驱动设计》里面的限界上下文是一个很棒的出发点， 它提供了一个从业务的角度去划分模块的方式。 拥抱自动化的文化微服务带来了很多复杂性，克服这些困难的关键是要拥抱自动化开发的文化，如自动化测试，持续交付等等实践。 隐藏实现细节采取无限技术的方式，例如REST，能够让你更自由地使用不同的技术栈。尽量隐藏实现的细节，服务的消费者不需要知道服务是用什么语言实现，是用什么样的数据库。 去中心化所有东西为了让每一个微服务尽可能的独立，去中心化所有的东西能够避免把所有的鸡蛋都放在一起。 独立部署通过蓝绿或者金丝雀部署方式，可以降低部署的风险。采用消费者驱动契约的方式能够尽早的发现问题。 隔离失败理解和计划失败是分布式系统的一部分，通过Bulkheads或者Circuit breakers模式能够有效的控制失败带来的影响。 高度可视化聚合所有的日志和状态，通过语义监控来观察系统是否正常。 使用correlation IDs可以方便地跟踪系统调用的痕迹。 分布式领域CAP理论 Consistency(一致性), 数据一性Availability(可用性), 好的响应性能Partition tolerance(分区容错性) 可靠性 定理：任何分布式系统只可同时满足二点，没法三者兼顾。CA不属于分布式系统，所以只考虑AP和CP。AP要比CP容易实现，具体用哪一种要看具体业务。 End这么多年来，我们不断地找到更好的方式去开发系统：Eric Evans‘s 《领域驱动设计》 帮助我们去了解让代码去呈现真实世界的重要性。《持续交付》告诉我们如何更加有效率的发布软件到生产环境。Alistair Cockburn的 六边形架构 告诉我们如何避免把业务逻辑四分五裂的隐藏在各层的架构上。各种虚拟化平台，如Amazon云、阿里云，允许我们去定制自己所需要的机器。最近，Netflix公司跟我们分享来一种 高扩展性的架构风格 ，既微服务架构，这种架构在十年前很难实现，幸运地是，今时不同往日。 ：）]]></content>
      <categories>
        <category>Tao</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[First Try of Gatling]]></title>
    <url>%2F2015%2F09%2F28%2FTech-2015-2015-09-28-FirstTryOfGatling%2F</url>
    <content type="text"><![CDATA[次时代压力测试工具：Gatling初体验 为什么用Gatling？因工作需要，要对HTTP接口进行专门的压力测试。经过一番考虑，我选择了 Gatling 。 Gatling 作为次时代的压力测试工具，具有高性能，结果报表友好，支持DSL等特点。 不同于它的前辈JMeter， Gatling 是基于Scala、Akka、Netty的。优点在于它对多并发测试有着强力的性能表现，缺点自然是学习曲线稍微高一点。 所以在性能上，Gatling的表现是优于JMeter的，这也是我为什么选择它的原因。 怎么用Gatling？既然它是基于Scala的，一门新语言对很多固守成规的人的来说，有着不小的心里成本。但还是可以有某些技巧可以减少学习成本，例如，可以直接从官方的例子来学习： gatling-maven-plugin-demo 我选择了和maven相关的例子，这样是为了以后方便和CI服务器集成。 首页就介绍了如何用maven去运行gatling，从运行入口BasicSimulation.scala 就可以学习基本的用法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package computerdatabaseimport io.gatling.core.Predef._import io.gatling.http.Predef._import scala.concurrent.duration._class BasicSimulation extends Simulation &#123; val httpConf = http .baseURL("http://computer-database.gatling.io") // Here is the root for all relative URLs .acceptHeader("text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8") // Here are the common headers .doNotTrackHeader("1") .acceptLanguageHeader("en-US,en;q=0.5") .acceptEncodingHeader("gzip, deflate") .userAgentHeader("Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:16.0) Gecko/20100101 Firefox/16.0") val headers_10 = Map("Content-Type" -&gt; """application/x-www-form-urlencoded""") // Note the headers specific to a given request val scn = scenario("Scenario Name") // A scenario is a chain of requests and pauses .exec(http("request_1") .get("/")) .pause(7) // Note that Gatling has recorder real time pauses .exec(http("request_2") .get("/computers?f=macbook")) .pause(2) .exec(http("request_3") .get("/computers/6")) .pause(3) .exec(http("request_4") .get("/")) .pause(2) .exec(http("request_5") .get("/computers?p=1")) .pause(670 milliseconds) .exec(http("request_6") .get("/computers?p=2")) .pause(629 milliseconds) .exec(http("request_7") .get("/computers?p=3")) .pause(734 milliseconds) .exec(http("request_8") .get("/computers?p=4")) .pause(5) .exec(http("request_9") .get("/computers/new")) .pause(1) .exec(http("request_10") // Here's an example of a POST request .post("/computers") .headers(headers_10) .formParam("""name""", """Beautiful Computer""") // Note the triple double quotes: used in Scala for protecting a whole chain of characters (no need for backslash) .formParam("""introduced""", """2012-05-30""") .formParam("""discontinued""", """""") .formParam("""company""", """37""")) setUp(scn.inject(atOnceUsers(1)).protocols(httpConf))&#125; 这个是一个很好的例子，从源码里我们可以轻易知道怎样去测试一个HTTP接口，无论是通过HTTP GET ，还是HTTP POST。 进阶使用Gatling从官方的文档中，得知Gatling支持读取csv格式的数据，这样进一步的方便我对测试数据的准备，为了测试简单，我采取了HTTP GET的方式。 我通过一个csv文件配置测试所需要的的数据： 然后改写测试代码来支持读取csv，这里采取了随即读取的方式： 12345678910111213141516171819val httpConf = http .baseURL("http://computer-database.gatling.io") // Here is the root for all relative URLs ...... val records = csv("api_scenario.csv", rawSplit = true).random val scn = scenario("API Performance Test") // A scenario is a chain of requests and pauses // inject project .feed(records) .exec(http("$&#123;scenario&#125;") .get("$&#123;api&#125;") .check(status.is(200)) ) val runUsers = Integer.getInteger("users", 1) setUp(scn.inject(atOnceUsers(runUsers)).protocols(httpConf)) baseURL(“http://xxx&quot;)方法决定的测试的URL， records定义测试的数据源。通过feed方法读取数据，exe方法执行，get方法采取HTTP GET方式，check方法检查返回结果（HTTP CODE） 变量runUsers则是定义一个外部传入的参数，代表测试的并发数。 运行Gatling一切就绪之后就可以运行测试了，以Intellij为例： gatling:execute -Dgatling.simulationClass=computerdatabase.API_Simulation -X -Dusers=10 gatling:execute 执行测试， 参数-Dgatling.simulationClass指定入口， －X 打开Maven的调试日志，-Dusers用户并发数。 运行之后日志如下： 打开结果报表 （../target/gatling/results/api-simulation-xxx/index.html）拉风的报表就出现了！ CI集成由于之前采取了Maven的命令行模式，所以把Gatling集成到Hudson／Jeskin也非常简单。 结论通过上面的步骤，一个简单而完整Gatling测试环境就搭建起来。 我的结论是， Gatling， 你值得拥有。 ：）]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Speak like TED]]></title>
    <url>%2F2015%2F08%2F20%2FOther-2015-2015-08-20-SpeakLikeTED%2F</url>
    <content type="text"><![CDATA[像TED一样演讲 《像TED一样演讲》是属于提升软技能技巧的书，遵循其中的技巧能让你的演讲别具一格。 一个让人难忘的演讲，是有情感的，让你感到新奇和难忘的。 #情感 有情感的演讲，是有热情的，融入一个故事里的，又像跟好友交谈一样自然。 ##热情热情将帮助你最大限度地施展自己的才能。 有热情的故事是有感染力的，要感染别人，先要感染自己，让自己的心灵歌唱。 一切都源自于你的动机，如果你的动机是分享你的热情，那很可能就不会那么紧张。 要成就伟业，就需要热爱自己的工作。获得真正的满足感。 热情是自我认同的核心，人们无法把他们的追求和他们自身分开，热情是他们存在的核心。 演讲越多，脑部结构变化越大，脑部的语言区域也越发达。 你的热情可以感染观众和员工，给追随者带来积极的情感体验。热情是一种领袖气质，能够引起观众的共鸣。 ##故事 故事是有灵魂的数据 通过故事，能把思想和情感植入观众的大脑，推倒人与人之间的一堵墙。 故事能给我一个我想要支持的人物，提高在商场中的竟争力。 简单却有效的三类故事： 个人故事 其他人的故事 产品／品牌的成败的故事 故事是有说服力的，说服力的三个要素是： 喻德 喻理 喻情 ##自然 确保非语言表达－－手势、表情和肢体语言，与语言协调 完善演讲 征求他人意见 早期反馈 练习、练习、还是练习 语言表达 语速（每分钟150～160个单词） 音量 声调 停顿 肢体语言像领导者一样讲话、走路和着装 手势能让有力的观点更加有力关键时刻使用，上不高眼睛、下不低肚脐 、 左右不超过双臂伸展、后不过眼睛。 纠正小动作纠正某些烦人的小动作如：坐立不安，原地不动，手插口袋等。有目的地做动作，不要一直站在观众面前。不要手插口袋，把手拿出来做手势，假装自信直到自信满满。 #新奇 新视角大脑喜欢新奇给人们一个看世界的新视角 人是天生的探险,我们都是探险“瘾君子”。换个视角看世界,探索你未知的领域 学习是一种快乐，快乐的时候大脑会产生多巴胺。多巴胺能够帮助记忆，是大脑中天然的“保存按钮”。 惊奇别用你惯用的手段糊弄群众设计让观众惊掉下巴的环节，调动多种感官——视觉、触觉、感觉来讲故事。抽象的信息需要具体的解释，如果观众无法理解你的信息，你就无法让他们“惊掉下巴”。 幽默别把自己看得太严肃。大脑喜欢幽默，你可以说下让群众发笑的话。但前提是你必须学会创造性，自然地把幽默融入你的演讲。 幽默是一种“取悦策略”，让人更容易被接纳。 5种制造幽默的方式： 趣闻、见解和个人故事 类比和比喻 引用 视频 照片 #难忘 你必须勇敢地表达自己的直觉和思想，不然那些本可以让人铭记的东西也会消失不见。 时间规则演讲时间越长，听众越焦虑。思考是个苦差事，听是一项让人疲惫不堪的活动。 听者会不断给大脑添加需要记忆和提取的信息，这就是“认知积压”。 一个乏味且漫长的演讲让听众的大脑不断地消耗能量，即大脑内大量的葡萄糖，而时长18分钟的演讲不会。 有约束才能激发创造力 对一个复杂的问题，如果演讲者能给出简单的解释，观众就会相信他精通这一学科。 如果你不能用简单的话把问题解释清楚，说明你还没有真正理解这个问题。 ——爱因斯坦 ###“三”的法则 简单是终极的复杂，事不过三。 人脑的短时记忆或工作记忆只能同时记住三个信息片段。 多感官体验解释某个想法时，图文并茂好过单纯的文字。 抓住观众吸引力的魔法是： 多感官体验 优秀的演讲通常以调动观众的某一个感官为主，同时也会刺激观众的至少一种其他感官：视觉、听觉、触觉、嗅觉和味觉。 视觉技巧： 多图，少字 听觉技巧： 用语言绘制一幅画 触觉技巧： 让观众“感同身受” 真实表现最真实的自己]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Art of Unit Testing]]></title>
    <url>%2F2015%2F08%2F03%2FArt-2015-2015-08-03-TheArtOfUnitTesting%2F</url>
    <content type="text"><![CDATA[单元测试的艺术 所有程序员都知道应该做单元测试！ 然而很多人却没有做，原因是各式各样的。就如Uncle Bob之前提到过的 The Little Mocker 中介绍Mock和Stub的关系一样, 这本书对一些容易混淆的概念作出了解释，也解释了实现的单元测试的难度和好处。 优秀单元测试的特质 自动化的代码 用自动化测试框架编写 容易编写 运行快速 能由开发团队里的任何人重复运行 三大支柱 可读性 可维护性 可靠性 用TDD的开发方式比较容易实现优秀的单元测试。 测试命名的规范[UnitOfWork]_[Scenario]_[ExpectedBehavior] 尽量不用［Setup］/ @Before 和 ［Teardown］/ @After ,用工厂方法代替。 用存根（Stub）破除依赖找到或者创造合适的中间层，在运行代码中注入存根。 存根（Stub） vs 模拟对象（Mock）存根不会让测试失败，不会在里面写断言，仅仅用来模拟各种场景。 模拟对象类似存根，但它能进行断言。 一个测试不能有多个模拟对象，它之外的伪对象都应该是存根。 隔离框架隔离框架很酷，关键在于如何自如地使用它们。 如果超过5%的测试使用模拟对象（而非存根），那就可能“过度指定”了，会导致代码既不可读，又容易失败。 隔离框架分2种： 受限 不受限 选择框架时要理解一个框架的能力和局限，大多数的受限框架在运行时生成和编译代码。 测试层次和组织 无论何种测试，都应该自动化 把集成测试和单元测试分开（慢和快测试分开，创造绿色安全区） 按项目和类型组织测试 使用测试类层次 把API介绍给队友 在组织中引入单元测试不要疏远可能帮助自己的人，准备好进行一场艰难的战斗： 理解影响力的力量。 遗留代码要了解各个组件的依赖数、逻辑量以及在项目中的优先级，从简单的开始。 处理遗留代码的时候，带上一瓶好伏特加也是个不错的主意。 （=_=）]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cucumber-BDD]]></title>
    <url>%2F2015%2F07%2F15%2FTech-2015-2015-07-15-Cucumber-BDD%2F</url>
    <content type="text"><![CDATA[Cucumber : 行为驱动指南 为什么要用Cucumber？Cucumber是一个实现BDD（行为驱动指南）的工具，为什么要使用它呢？ 软件始于一个想法。 但是，如果一个开发人员误解的一个想法，然后花了2周的一次迭代实现了它，那么他不仅仅浪费了2周的时间，还引入一些误解最初想法的概念和功能，破坏了代码的完整性。 这就是cucumber要解决的问题，作为一种过滤器，过滤那些被误解的想法。 自动化验收测试单元测试确保你正确地编写软件，验收测试确保你编写正确地软件。 通用语言Cucumber为存在语言分歧的双方，提供可以发现和使用通用语言的场所。 活的文档用Cucumber编写的文档，是可执行的规格说明（executable specification）， Overview Gherkin基础 Gherkin是一种DSL，是可执行的规格说明。它以.feature为后缀名，以简单文本格式保存。 关键字 Feature Background Scenario Scenario outline Scenarios (or examples) Given When Then And (or But) | (用来定义表格) “”” (定义多行字符串) (注释) 模拟运行$ cucumber test.feature --dry-run 解析不执行 Feature每一个Gherkin文件都以Feature关键字开头。它只是提供一个地方，放置与测试相关的摘要文档。 合法的Gherkin必须包含以下其中一个元素： Scenario Background Scenario outline 场景场景是特定情形下有关系统行为的具体实例，所有的场景会和起来就是这个特性期望的行为。 无状态每个场景都必须有独立的意义，且能够不依赖其他场景独立运行。 多语言支持Cucumber支持多国语言来编写 , 以下目录显示所有支持的语言 $ cucumber --i18n help 步骤场景中的每一行都是一个步骤 Given、When、ThenGiven 用来建立场景发生的上下文When 以某种方式与系统交互Then 检查交互的结果是否符合预期 And、But使用And／But 可以为Given、When、Then增加更多的步骤。 星号（＊）不想用Given、When、Then的时候，每一行都是＊开始就行。 注释（＃）#comment sth 步骤定义 步骤定义在业务领域和编程领域的边界上。 两面对外把普通语言翻译成程序，对内使用自动化代码告诉系统做什么。 步骤与步骤定义步骤只是用普通语言编写的文档，步骤定义赋予其生命。 匹配步骤Cucumber扫描每个步骤的文本，通过正则表达式来寻找对应的步骤定义。 例子1234567Feature: 网页搜索 Scenario: 在百度里搜索谷歌 Given 打开浏览器到baidu.com And 输入 "google" When 点击百度一下 Then 见到搜索结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Created by Antinomy on 15/6/10. */import cucumber.api.CucumberOptions;import cucumber.api.java.en.*;import cucumber.api.junit.Cucumber;import domian.driver.Brower;import domian.lifeCycle.PageConfRepository;import org.apache.log4j.Logger;import org.junit.runner.RunWith;import org.openqa.selenium.By;import java.io.File;import java.net.MalformedURLException;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.core.Is.is;@RunWith(Cucumber.class)@CucumberOptions(plugin = &#123;"pretty", "html:target/cucumber"&#125;)public class BaiduExample_Test &#123; public Brower brower; private PageConfRepository page; private static Logger logger = Logger.getLogger(Brower.class); public BaiduExample_Test() throws Exception &#123; page = new PageConfRepository("baiduExample.yaml"); brower = Brower.getInstance(); brower.open(); &#125; @Given("打开浏览器到baidu.com") public void go_to_baidu_com() throws MalformedURLException &#123; logger.debug("打开浏览器到baidu.com"); brower.go(page.getConf("baiduPage", "url")); &#125; @And("^输入 \"(.*?)\"$") public void input_in_text(String keyWord) throws Throwable &#123; logger.debug("输入 " + keyWord); brower.inputText(page.getId("baiduPage", "input_id"), keyWord); &#125; @When("^点击百度一下$") public void he_click_the_search_buttom() throws Throwable &#123; logger.debug("点击百度一下"); brower.click(page.getId("baiduPage", "searchBtn_id")); &#125; @Then("^见到搜索结果$") public void he_should_be_see_search_result() throws Throwable &#123; logger.debug("见到搜索结果"); assertThat(brower.getTitle(), is("google_百度搜索")); brower.close(); &#125; 正则表达式1@And("^输入 \"(.*?)\"$") 捕获组（A｜B）： 用（）包围的那部分，加上｜可多选分支 点号（.）: 匹配单个任意字符 星号（＊）： 任意多次 加号（＋）： 至少一次 问号（？）： 0或1次 字符组： \d 代表数字，［0-9］ \w 代表单词字符 ［A－Za－z0-9］ \s 代表空白字符 ［\t\r\n］ \b 代表单词边界，任何不是单词字符的都是单词边界 大写则是代表相反结果，如\D表示任意非数字字符 非捕获组就是正则表达式之外的那部分。如例子里的“输入”。 锚点步骤 以 ^开头 $结尾 ，保持紧凑。 Given、When、Then是相等的Cucumber在匹配步骤的时候是忽略这几个关键字的。 返回结果 未定义 (undefined) 待定 (pending) 失败 (failed) 通过 (passed) 富有表现力的场景背景 （Background）背景： 指定一组所有场景的公共步骤，相当于Junit里的@Before 不设置复杂状态 保持简短 鲜明生动 避免技术细节 12345678910111213141516171819202122232425Feature: Multiple site support As a Mephisto site owner I want to host blogs for different people In order to make gigantic piles of money Background: Given a global administrator named "Greg" And a blog named "Greg's anti-tax rants" And a customer named "Dr. Bill" And a blog named "Expensive Therapy" owned by "Dr. Bill" Scenario: Dr. Bill posts to his own blog Given I am logged in as Dr. Bill When I try to post to "Expensive Therapy" Then I should see "Your article was published." Scenario: Dr. Bill tries to post to somebody else's blog, and fails Given I am logged in as Dr. Bill When I try to post to "Greg's anti-tax rants" Then I should see "Hey! That's not your blog!" Scenario: Greg posts to a client's blog Given I am logged in as Greg When I try to post to "Expensive Therapy" Then I should see "Your article was published." 数据表 (data table)123| start | eat | left || 12 | 5 | 7 || 20 | 5 | 15 | 数据表本质上是一个二维数组，是Gherkin的一个重要特性。使用raw()方法可以获取原始格式，使用diff！可以比较数据表。 场景轮廓 （Scenario Outline）123456789Scenario Outline: eating Given there are &lt;start&gt; cucumbers When I eat &lt;eat&gt; cucumbers Then I should have &lt;left&gt; cucumbers Examples: | start | eat | left | | 12 | 5 | 7 | | 20 | 5 | 15 | 场景轮廓用于遵循同样步骤的场景，使用它的前提是要有一个实例表（Examples，可以用Scenarios代替），通过它的占位符是尖括号 (&lt;..&gt;)，将实例表的每一行转换成一个场景再执行。 其中一个优点就是：你能够清楚地看到实例中遗漏的东西。通过使用更大的占位符，可以有效地减少重复的内容。但是这一切的底线是不能影响可读性，最终目的是为了能够解释自己。 嵌套步骤12345678910When /^I make all my stuff shiny$/ step "I polish my first thing"endWhen /^I make all my stuff shiny$/ steps %&#123; When I polish my first thing When I shine my second thing &#125;end 通过steps %{}可以把一些步骤归纳成更抽象的步骤，但过度使用就会带来不必要的复杂性。 文档字符串123""" many word ... together """ 1对的三个双引号”””之间，可以把一大堆文本(html/json/*)放置在内。 保持条理性使用子文件夹和标签可以更有条理的管理特性，标签用@开头，可以通过命令行运行某个子文件夹或标签里的内容。 1234567@billingFeature: Verify billing @important Scenario: Missing product descriptionScenario: Several products 常见问题及解决之道感受痛苦闪烁的场景 偶尔失败，随机失败的场景为闪烁的场景。 解决它需要研究代码，弄清为什么会发生。通常有以下问题所导致： 共享的环境 渗露的场景 竞争条件和打瞌睡的步骤 脆弱的特性 脆弱的特性极易被破坏。特性脆弱时，在测试套件或主代码库的某个部分做些必要的修改会破坏明显不相关的场景。 脆弱的特性通常由以下问题之一所引发。 固件数据 重复 渗露的场景 被隔离的测试人员 缓慢的特性缓慢的特性通常由下列问题的某种组合引发。 竞争条件和打瞌睡的步骤 大量场景 大泥球 厌倦的利益相关人一开始就同业务利益相关人建立正确的协作关系。如果他们觉得自己太忙，没时间帮你准确理解他们想要的东西，那么你面对的是一个更深层的团队问题，Cucumber爱莫能助。 但另一方面，许多团队开始时倒是有热心主动的利益相关人，可团队却浪费了Cucumber带来的建立这种协作关系的机会。如果测试人员或开发人员独自编写特性，他们就难免使用技术术语，这样利益相关人在阅读的时候会觉得自己被边缘化了。 这会变成恶性循环：利益相关人本来可以帮助你使用对他们有意义的语言编写特性，但随着兴趣渐失，他们花在这上面的时间会越来越少。不知不觉中，特性就沦为纯粹的测试工具了。 这一痛苦症状通常由下列问题的某种组合引发。 偶然细节 命令式步骤 重复 语言不通用 闭门造车式的特性 同心协力Cucumber的特性正是Gojko Adzic 所说的活文档（living documentation）。这一术语恰如其分地总结了使用Cucumber的两大好处。 活的：能自动测试系统，以便你可以安全地工作。 文档：便于大家有效地沟通系统的当前行为和预期行为。 偶然细节像密码这种在场景中提及但实际上与场景的目标毫无关系的细节，我们称之为偶然细节（incidental detail） 。这种不相关的细节使得场景很难阅读，而这又会让利益相关人对阅读场景失去兴趣。 避免偶然细节 编写场景的时候，尽力避免被已有的步骤定义所左右，只管用直白的语言把你希望发生的事情确切地写下来即可。 事实上，尽量不要让程序员或测试人员独自编写场景。让非技术的利益相关人或者分析师从纯粹以业务为中心的角度出发编写每个场景的初稿，或者最理想的情况是与程序员结对，从而分享他们的构思模型。 有了工程意义上设计精良的支持层，你便可以信心百倍地快速编写新的步骤定义来配合场景的表达方式。 命令式步骤命令式编程是指使用一个命令序列，让计算机按特定的次序执行它们。 Ruby就是命令式语言的例子：你把程序写成一系列的语句，Ruby按顺序每次执行其中的一条语句。 声明式编程则告诉计算机应该做什么（what），而并不精确指明如何（how）去做。 CSS就是声明式语言的例子：你告诉计算机希望Web页面上的各种元素如何呈现，剩下的让计算机去处理。 Gherkin当然是命令式语言。Cucumber按照你编写的顺序依次执行场景中的每个步骤，每次执行一步。但这并不意味着这些指令读起来要像装配组合家具的说明书一样。 最严重的是，使用这样的泛化步骤定义写出的场景无法创建出场景的领域语言。 Gherkin特性中在命令式风格和声明式风格之间并没有明确的界线。 相反，这是一个连续的频谱，每个场景中每个步骤在频谱上的正确位置取决于许多方面：你所描述的系统领域，你所构建的应用类型，程序员的领域知识，以及非技术利益相关人对程序员的信任水平。 如果利益相关人希望在特性中看到许多细节，这或许表明你需要努力改善这一信任，但也可能说明你们开发的系统就是需要详述很多细 节的。 重复DRY原则 （Don&apos;t Repeat Yourself）指出，任何概念的定义应当在代码中出现且仅出现一次。 这是一个了不起的目标，因为你如果必须对系统的行为做出修改，肯定希望只在一个地方修改，同时又对改动很有信心，相信它会一致地应用于整个代码库。如果那种行为散落在代码的多处定义中，不但你自己无法全部找到它们，很可能在你之前因为别人也不能全部找到，结果那些定义已经彼此不一致了，谁愿意这样呢？ 然而，在你用实例驱动代码的时候，我相信有另外一个原则优于DRY：实例应当讲出一个好故事。实例是给未来的程序员（包括你自己，如果在3个月以后你会回来修改这段代码的话，那时你已经忘记它做的是什么了）提供指导的文档叙述。 假设你读这样一本书：里面所有的情节和人物都按照DRY原则给抽干了，一切只出现在脚注或附录中。所有的人物描述、情节元素、潜台词等都被仔细抽取出来，做成交叉引用的章节。如果你是在读百科全书，这非常好，但如果你想投入到故事流中，弄清楚发生的事情，这样就不太合适了。你会在书中无休止地来回翻阅，而且很快会忘记故事看到哪儿了。借用一个古老的玩笑，字典里面密密麻麻全是情节，但在”情节”的行进中，它们至少解释了所有的单词。 有些人把这称为DAMP（Descriptive and Meaningful Phrases）原则：描述性且有意义的叙述。编写实例的时候，可读性压倒一切，于是DAMP高于DRY。 语言不通用我们讨论的是开发一种通用语言，因为这是一个持续进行的过程。这一开发过程需要我们工作上的投入。真正做到彼此倾听并且就使用的词语达成一致是需要努力的，而坚持这种约定也是需要纪律的。 然而，回报是巨大的。使用通用语言的团队犯错更少，且更能享受工作的乐趣，因为他们能有效地沟通工作内容。 不重视通用语言价值的团队将会粗枝大叶地使用场景中的语汇，从而丧失在团队中专注技术和专注业务的双方之间构筑坚固桥梁的宝贵机会。那时，如果你试图纠正别人或澄清术语，带给人的感觉只会是吹毛求疵。 闭门造车式的特性人们会觉得Cucumber是一种技术性较强的工具。它从命令行运行，特性文件也被设计成需要与被测代码一道签入版本控制系统。然而它却以帮助提高团队的业务利益相关人对开发过程的控制感为目标。当测试和开发尽情把特性塞入版本控制的时候，团队中其他人会觉得他们的文档被锁进了柜子，而他们却没有钥匙。 你只需要坚持做到同业务利益相关人一起坐下来协作编写场景，就足以收获Cucumber至少一半的好处。这一过程所激发的交谈会解开太多太多的潜在bug或时间延误，即便你从不打算将特性自动化，也已经收获颇丰了。 照管好你的测试自动化特性的好处在于你可以把它们作为活文档来长期信赖，因为你会将每一个场景都用于检查产品代码，以确保它们仍然有效。 对于同代码打交道的程序员来说，这还有另一件好处：在他们开发系统的时候，那些测试可以充当安全网，对任何破坏已有行为的错误都给出警告。 渗露的场景Cucumber场景本质来说是状态转换，如果2个测试之间存在状态依赖，那就发生了渗露（leak） 每个场景都是独立的，可以确保场景将系统置于干净的状态，然后再添加自己的数据。 竞争条件和打瞌睡的步骤端对端的测试里，终究会遇到竞争条件和沉睡的步骤的问题。 一种粗糙的解决方法就是引进固定时长地停顿或睡眠。 如果一定要作出选择，我们宁可要缓慢但可靠的测试，也不要更快但不可靠的测试。 但如果熟知系统工作原理，就可以利用系统隐含的线索让测试知道何时能够安全地前进。 共享的环境对单一环境的共享使用会对数据库这种紧张地资源造成沉重且不稳定的负荷，从而造就不可靠的测试。 解决之道在于“一键式搭建系统” 被隔离的测试人员测试人员不应该被看作二等公民，应该与开发人员结对，创造结构更清晰，更稳健的测试套件。 这样测试人员就可以解放自己，去做更有趣、更有创造性的探索性测试。（exploratory testing） 固件数据 （fixture data）固件数据，即使开始时相对精简，时间长了体积也会只增不减。随着越来越多的场景开始依赖这些数据，且每个场景都要对它们做一点特别的处理，固件数据的体积会越来越大，复杂度也会越来越高。 当你为了某个场景对数据做点改动，结果却使其他场景失败时，你将开始感受到脆弱的特性的痛苦。 有这么多不同的场景依赖于固件数据，你会倾向于糊上更多的数据，因为这比修改已有的数据更加安全。某个场景失败时，你很难清楚系统中的哪一团数据可能跟失败相关，诊断起来也更加困难。 我们认为固件数据是一种反模式（antipattern）。 我们更倾向于使用之前介绍过的测试数据构造器，比如FactoryGirl ，那样可以让测试本身从内部创建相关数据，而不是让这些数据淹没在一大团混乱的固件数据集合中。 大量场景数量巨大的特性很难组织得井井有条，可通过子文件夹和标签来合理组织。 另外一种方法就是考虑下移一些到单元测试里。 大泥球软件架构一团糟得情况叫做大泥球（Big Ball of Mud）。 Alistair Cockurn的端口和适配器（port and adapter）架构是一种让系统容易测试的架构，建议使用. 勾勒出领域模型任何面向对象程序的核心都是领域模型。 基于领域模型工作，而不是用户界面上的各种花样。 一旦有了能够反映我们对系统理解的领域模型，给它包上漂亮的外衣是很容易的事情。 准确用词实话实说做最简单的事情]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Richardson Maturity Model]]></title>
    <url>%2F2015%2F07%2F03%2FArt-2015-2015-07-03-RichardsonMaturityModel%2F</url>
    <content type="text"><![CDATA[Richardson Restful成熟度模型走向荣耀的RESTLeonard Richardson提出的一个模型，把REST方法的主要元素分解成三步。它们包括：资源，http 动词，超媒体控制。 作者 : Martin Fowler译者 : A生原文地址 内容 [Level 0][Level 1 - 资源][][Level 2 - http 动词][][Level 3 - 超媒体控制][] 最近我正在读《 Rest In Practice 》的草稿， 一本我的同事们写的书。他们的目的是解释如何使用Restful web服务来处理许多企业面临着的集成问题。这本书的核心是认为网络是一个存在的、经证实工作得很好的、大规模可伸缩的分布式系统。我们根据这样的想法，可以更容易地构建集成系统。 Figure 1: Steps toward REST 为了更好的解释一个web风格系统的特殊属性，作者们用了一个由Leonard Richardson提出的restful成熟度模型，并在一个QCon talk的时候解释过它。这个模型是很好的方式去思考那些技术，所以我把自己的解释也穿插在内。（这里关于协议的例子只是为了说明问题，我不认为它值得去写代码和测试，所以在细节实现上可能会有些问题。） [Level 0]这个模型的起点是，为了远程调用，使用HTTP来作为一个传输系统，但不使用任何web的机制。基本上你所做的是使用HTTP作为隧道机制为自己的远程交互机制,通常基于远程过程调用。 Figure 2: An example interaction at Level 0 让我们假设我要预约我的医生。我的预约软件首先需要知道我的医生什么时候有空，所以它向医院的预约系统请求这些信息。在level 0的情景下，医院将在某个URL开放一个服务端点。然后我向该端点post一个带有我的请求所有细节的文档。 1234POST /appointmentService HTTP/1.1[various other headers]&lt;openSlotRequest date = "2010-01-04" doctor = "mjones"/&gt; 服务器会返回一个给我对应信息的文档。 12345678&lt;openSlotList&gt; &lt;slot start = "1400" end = "1450"&gt; &lt;doctor id = "mjones"/&gt; &lt;/slot&gt; &lt;slot start = "1600" end = "1650"&gt; &lt;doctor id = "mjones"/&gt; &lt;/slot&gt;&lt;/openSlotList&gt; 我在这里用了XML作为例子，但其内容可以实际上可以是任何格式：JSON、YAML、key－value pairs，或者其他自定义格式。 我的下一步是进行预约，所以我可以向服务端点再次post一个文档。 1234567POST /appointmentService HTTP/1.1[various other headers]&lt;appointmentRequest&gt; &lt;slot doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointmentRequest&gt; 顺利的话，我会收到一个告诉我预约成功的回应。 1234567HTTP/1.1 200 OK[various headers]&lt;appointment&gt; &lt;slot doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointment&gt; 如果出现问题，某人在我之前就预定了，那我会在回答的结构内得到某种错误消息。 12345678HTTP/1.1 200 OK[various headers]&lt;appointmentRequestFailure&gt; &lt;slot doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt; &lt;reason&gt;Slot not available&lt;/reason&gt;&lt;/appointmentRequestFailure&gt; 目前为止，这就是一个直截了当的RPC风格的系统。它很简单，它只是来回抛出普通XML（POX）。同样原理，如果你使用SOAP 或 XML－RPC的话，唯一的不同就是你怎样去封装XML消息。 [Level 1 - 资源]向RMM迈向荣耀的第一步是引入资源。 Figure 3: Level 1 adds resources 所以我们初始的查询里，我们会有给医生的一个资源。 1234POST /doctors/mjones HTTP/1.1[various other headers]&lt;openSlotRequest date = "2010-01-04"/&gt; 答复里携带同样基本的消息，但是每一个时间段都是一个可以独立对应的资源。 12345678HTTP/1.1 200 OK[various headers]&lt;openSlotList&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;slot id = "5678" doctor = "mjones" start = "1600" end = "1650"/&gt;&lt;/openSlotList&gt; 带着特殊资源的预约意味着post着一个特定的时间段。 123456POST /slots/1234 HTTP/1.1[various other headers]&lt;appointmentRequest&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointmentRequest&gt; 一切顺利的话，我会得到一个跟之前相似的回应。 1234567HTTP/1.1 200 OK[various headers]&lt;appointment&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointment 现在的区别是任何人需要做关于预约的任何事情，如测试一些预定，他们会先持有预约的资源，那可能是一个URL（e.g. http://royalhope.nhs.uk/slots/1234/appointment）,然后post那个资源。 对于像我这样一个（面向）对象佬，这个就像是去定义对象的概念。而不是在以太之间调用函数和传参，我们调用一个为其他信息提供参数的特别的对象。 [Level 2 - http 动词]我在所有level 0 和 1之间的交互里使用HTTP POST 动词，但是一些人用GETs 来取代或添加。在那些level里，那并没有多少不同，他们都是被用作于允许您通过HTTP交互的隧道传输机制。level 2 比这个更进一步，在HTTP本身的机制里尽可能地使用HTTP动词。 Figure 4: Level 2 addes HTTP verbs 为了我们列表中的时间段，这个意味着我们要使用GET。 12GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1Host: royalhope.nhs.uk 答复和之前一样使用POST， 1234567HTTP/1.1 200 OK[various headers]&lt;openSlotList&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;slot id = "5678" doctor = "mjones" start = "1600" end = "1650"/&gt;&lt;/openSlotList&gt; 在level 2里，像这样在请求中使用GET是至关重要的。HTTP定义GET为一个安全的操作，它不会对任何事物的状态作出重大改变。这样允许我们在任何次数、任何顺序去安全地调用GETs，每次都得到相同的结果。一个重要的结论是：它允许任何参与者在请求的路由里使用缓存，这是一个让web正常发挥它本身特性的关键元素。HTTP包括了很多措施去支持缓存，可以用于任何交互者的沟通里。遵循HTTP的规则，让我们能够去利用这种能力的优点。 为了预约，我们需要一个HTTP动词去改变状态，一个Post或PUT。我会使用和之前一样的POST。 123456POST /slots/1234 HTTP/1.1[various other headers]&lt;appointmentRequest&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointmentRequest&gt; 在这里权衡使用POST和PUT超过了我在这要说的范围，也许某天我会为了他们另起一篇文章。但我想指出,一些人错误地把POST/PUT等同于create/update。它们之间的选择是相当不同的。 就算我在level 1用于同样的post，那里有另外一个重要的不同之处，在于远程的服务怎样去回应。如果一切顺利，服务应答了一个响应代码201，来表明这个世界上多了一个新的资源。 12345678HTTP/1.1 201 CreatedLocation: slots/1234/appointment[various headers]&lt;appointment&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointment&gt; 201的响应包括一个位置属性的URI，所以客户端在未来可以去用GET那个资源的当前状态。这里的响应还包括该资源的展示，去保存当前客户端一个额外的调用。 另外一个不同的区别，如果那里出现错误，如某人有预定的那个时间。 123456HTTP/1.1 409 Conflict[various headers]&lt;openSlotList&gt; &lt;slot id = "5678" doctor = "mjones" start = "1600" end = "1650"/&gt;&lt;/openSlotList&gt; 这个应答中重要的部分，用一个HTTP的响应代码去识别那里出现了错误。在这种情况下,409似乎是一个不错的选择,表明其他人已经在一个不兼容的方式下去更新资源。而不是使用响应代码200但又包含了错误的响应，在level 2 我们显然使用某种像这样的错误响应。那是由协议设计者来决定使用什么代码，但是一个错误出现时，应该使用一个非2xx的响应代码。Level 2 介绍了使用HTTP动词和HTTP响应代码。 在这里有一个矛盾。REST提倡使用所有的HTTP动词。他们也在证明他们的方法：REST是试图学习web的实际成功的一面。但是万维网在实际应用很少使用PUT或DELETE。合理使用PUT和DELETE的情况越来越多，但是web的存在证明并不是其中一个。 支持web存在的关键元素，是严格地分离来安全（例如GET）和非安全的操作，一起用状态码来帮助沟通遇到的各种错误。 [Level 3 - 超媒体控制]最后的level介绍了一个你经常听到的一个丑陋的缩写：HATEOAS (Hypertext As The Engine Of Application State)。它解决的问题是：如何从一个开放的时间段里，去知道预约应该做些什么？ Figure 5: Level 3 adds hypermedia controls 我们开始同样初始化的GET，跟我们在level 2 发送的一样。 12345678910111213141516171819202122GET /doctors/mjones/slots?date=20100104&amp;status=open HTTP/1.1Host: royalhope.nhs.uk``` 但是应答里多了一个新元素 ``` xmlHTTP/1.1 200 OK[various headers]&lt;openSlotList&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"&gt; &lt;link rel = "/linkrels/slot/book" uri = "/slots/1234"/&gt; &lt;/slot&gt; &lt;slot id = "5678" doctor = "mjones" start = "1600" end = "1650"&gt; &lt;link rel = "/linkrels/slot/book" uri = "/slots/5678"/&gt; &lt;/slot&gt;&lt;/openSlotList&gt; 现在每一个时间段包含了一个URI，告诉我们如何去预约。 超媒体控制的关键在于告诉我们，接下来我们能做什么，和我们需要操作的资源的URI。而不是我们必须要知道那里可以post我们的预约请求，超媒体控制的应答里告诉了我们如何去做。 POST 会再次复制level 2的 123456POST /slots/1234 HTTP/1.1[various other headers]&lt;appointmentRequest&gt; &lt;patient id = "jsmith"/&gt;&lt;/appointmentRequest&gt; 然后应答里包括了一系列为了不同事情的下一步的超媒体控制。 1234567891011121314151617181920HTTP/1.1 201 CreatedLocation: http://royalhope.nhs.uk/slots/1234/appointment[various headers]&lt;appointment&gt; &lt;slot id = "1234" doctor = "mjones" start = "1400" end = "1450"/&gt; &lt;patient id = "jsmith"/&gt; &lt;link rel = "/linkrels/appointment/cancel" uri = "/slots/1234/appointment"/&gt; &lt;link rel = "/linkrels/appointment/addTest" uri = "/slots/1234/appointment/tests"/&gt; &lt;link rel = "self" uri = "/slots/1234/appointment"/&gt; &lt;link rel = "/linkrels/appointment/changeTime" uri = "/doctors/mjones/slots?date=20100104@status=open"/&gt; &lt;link rel = "/linkrels/appointment/updateContactInfo" uri = "/patients/jsmith/contactInfo"/&gt; &lt;link rel = "/linkrels/help" uri = "/help/appointment"/&gt;&lt;/appointment&gt; 超媒体控制一个明显的好处在于：允许服务端在不破坏客户端的情况下，去修改它自己的URI scheme。除了最初的入口点，只要客户端寻找“addTest” 链接URI，服务端团队可以处理所有的URI。 一个长远的好处就是它帮助客户端的开发者去探索协议。那个链接给客户端开发者一个接下来可能是什么的提示。它不会给予所有的信息：指向同一个URI，“最近的”和“取消”的控制－－他们需要找出一个是GET和另外一个是DELETE。但至少它给了他们一个起点,去考虑的更多信息，和在协议文档里寻找一个类似的URI。 同样地它允许服务端团队通过响应里的新链接去宣传新的功能。如果客户端开发者密切留意那些未知的链接，这些链接可以触发进一步的探索。 那里没有绝对的标准关于如何去表示超媒体控制。我在这里所做的是，在一个实践的团队里去使用当前建议的REST，这是遵循ATOM （RFC 4287 ）我为了一个目标的URI和一个rel属性，用一个带一个uri属性的 元素去描述这种关系。一个众所周知的关系(如引用自己本身的元素)是赤裸的,任何特定的服务器是一个完全限定的URI。ATOM说明知名linkrels的定义是：链接关系的注册表我所写的这些界限于ATOM所做的，通常被看作是安静的level 3里一个领导者。 Levels的定义 我应该强调RMM,是一个好的方式去思考什么是REST的元素,而不是一个REST本身级别的的定义。Roy Fielding已经清晰地指出 level 3 是REST的一个前置条件就像软件里的很多缩写，REST拥有许多的定义，但从Roy Fielding 杜撰了这个缩写开始，他的定义应该比大多数人更有分量。 我觉得这个RMM有用的是,它提供了一个很好的方式，一步步去理解restfull思维背后的基本想法。因此我认为这是来帮助我们了解概念的工具，而不是某种评价机制。我不认为我们有足够多的例子，去真正确保restful方式是集成系统的正确方法。在我建议的大多数情况下，我认为这是一个非常有吸引力的方法。 和Ian Robinson讨论这个时，他强调当Leonard Richardson首次提出它时，这个模型具有吸引力的地方是，这是常见的设计技术的关系。 + Level 1 处理复杂性的问题通过使用分而治之,把一个大型的服务端点分解成多个资源。 + Level 2 引入一组标准的动词,这样我们可以以同样的方式处理类似的问题,消除了不必要的不确定性。 + Level 3 引入可查找性,提供一种方式让协议更具可读性。 结果是，一个模型帮助我们去思考我们想要一个怎样的HTTP服务，去提供和设计人们希望与之交互的期望。]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Test Assert Mock]]></title>
    <url>%2F2015%2F05%2F27%2FArt-2015-2015-05-27-Test-Assert-Mock%2F</url>
    <content type="text"><![CDATA[测试 断言 模拟 Test在很多人眼里，测试是一类东西：交给测试人员做的事情。其实，测试有很多不同的种类（详见上图），不同的测试应用场景也不同。 跟开发者密切相关的测试有： 提交测试 单元测试 组件测试 集成测试 测试是有成本的。编写要成本，运行要成本，维护更需要成本！ 成本最小的应该是提交测试，顾名思义，提交测试就是提交代码之前必须要运行的测试。如果每次提交都要等个半个小时，那么估计很少人愿意频繁提交代码了。 ：）提交测试的内容应该是单元测试里面比较重要的部分。 单元测试，必须要快！如何做到唯快不破？ 答案很简单： No IO No DB No Network 业务代码不应该依赖：文件IO操作、DB读写，以及网络层面的外部调用。所以好的设计很重要，把业务代码和IO／DB／Network 分离出来，对设计人员要求是有的。DDD（领域驱动开发）在这方面做了很好的研究，例如Repository模式就很好的隔离业务和DB／IO之间的耦合。 DB／IO ／Network 并不是不重要关于它们的测试放在组件测试和集成测试的范畴,而这2个测试成本也越高。DB和IO操作放在组件测试里去做，RPC之类的远程调用则放在集成测试里。 AssertSystem.Out.print()在Java的世界里，最简陋的测试莫过于System.Out.print()啦。 假如我们有一个方法，我们期待它能返回数字5. 1int anNum = getSomeNum5(); 如果采用print的方法，那么我们就直接的写下， 1System.Out.print(anNum); 然后我们在控制台里看print出的数字，看看是不是5.这样做的缺陷是，必须得人肉验证，你得盯着结果看。 Junit如果你有用过Junit，那么我们就可以使用更高级点的断言了。 12345678910111213141516/** * Created by Antinomy on 15/5/27. */public class SampleTest &#123; @Test public void test() &#123; int anNum = getSomeNum5(); assertEquals(5,anNum); &#125; private int getSomeNum5() &#123; return 0; &#125;&#125; 然后，我们就可以愉快的运行测试了，很多IDE都会把结果用绿色和红色显示出来。 assertEquals(5,anNum)的意思期待的返回的值是5，实际返回的是getSomeNum5()的结果。我们修改一下getSomeNum5()的“bug”，测试就通过了。 Hamcrest那么测试通过了，我们就完事了么？按照TDD的三部曲，红（失败），绿（通过），重构。接下来要做的是重构。为什么要重构？ 因为我们是有追求的人。 ：） 好吧，如果你也是一个有追求的人，那么让我们来重构吧。assertEquals这个关键字有一些生硬的感觉，代码可读性上一般般。这个时候，我们该祭出神器Hamcrest了。 Hamcrest is a library of matchers, which can be combined in to create flexible expressions of intent in tests. 采用Hamcrest重构过的代码如下： 12345678910111213141516171819202122import org.junit.Test;import static junit.framework.TestCase.assertEquals;import static org.hamcrest.core.Is.is;import static org.junit.Assert.assertThat;/** * Created by Antinomy on 15/5/27. */public class SampleTest &#123; @Test public void test() &#123; int anNum = getSomeNum5(); assertThat(anNum, is(5)); &#125; private int getSomeNum5() &#123; return 5; &#125;&#125; assertThat(anNum, is(5)); 假设anNum is 5， 可读性层面立马上去了。重构完，如何保证之前的修改不容易扯到蛋？当然是之前写的测试啦，用了成本的投资必须要有回报，所以重新跑一下之前的测试就知道重构的质量如何了。 Mock以上的例子，只是一个很理想的例子。生活中总有许多不如意的事情，比如，如果getSomeNum5()方法不是本地实现的，而是来自于某个神秘的国度。你甚至不知道它是用什么语言实现的，那么测试的难度也提高了很多。 如下： 1234567891011121314151617181920212223242526272829/** * Created by Antinomy on 15/5/27. */public class SampleTest &#123; @Test public void test() &#123; Num5 someWhere = new SomeWhere(); int anNum = someWhere.getSomeNum5(); assertThat(anNum, is(5)); &#125;&#125;// interfacepublic interface Num5 &#123; int getSomeNum5();&#125;// SomeWherepublic class SomeWhere implements Num5 &#123; public int getSomeNum5() &#123; return 5; &#125;&#125; 如果你知道有一个叫Num5的接口，而它的具体实现是有另外一个团队来实现的，不幸的是那个团队还没完成功能。 难道我们能做的事情只能是等待？？NO！ 我们已经知道接口了，知道它该有的功能是什么。所以我们可以假扮它了，嘿嘿～ Mockito这个时候我们该祭出神器 Mockito了。 Tasty mocking framework for unit tests in Java 使用Mockito，你就不需要知道真正的SomeWhere是这么实现的，你只需要假扮它。 123456789101112131415161718192021222324252627import static org.hamcrest.core.Is.is;import static org.junit.Assert.assertThat;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;/** * Created by Antinomy on 15/5/27. */public class SampleTest &#123; @Test public void test() &#123; Num5 someWhere = getNum5Mock(); int anNum = someWhere.getSomeNum5(); assertThat(anNum, is(5)); &#125; private Num5 getNum5Mock() &#123; Num5 result = mock(Num5.class); when(result.getSomeNum5()).thenReturn(5); return result; &#125;&#125; 在以上的这段代码里，我们并不知道Somewhere是怎么实现的， 我们用了一个假扮的result去模拟Num5接口的实现。when(result.getSomeNum5()).thenReturn(5);当call到getSomeNum5()方法时，then Return 5 了。 这样，我们就可以在Somewhere团队完成功能之前，模拟返回5，返回不是5的各种情况。事先调试好集成代码，等到他们完工的时候，再切换成真正代码的调用。 mock不是上策，它只是对不完美的设计的一种妥协。 小结好吧，我们成功地把一句print语句，复杂到要用接口，mock等方式来实现。宇宙的熵就是这么来的，哈哈。 写测试的时候需要精心设计测试用例，需要有丰富的想象力，需要有一颗跨界的心。 Further Reading你应该更新的Java知识之常用程序库（二） [Sample Codes][https://github.com/Antinomy/Antinomy.github.io/tree/master/sampleCodes/testWithMock/]]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beck Design Rules]]></title>
    <url>%2F2015%2F05%2F17%2FArt-2015-2015-05-17-BeckDesignRules%2F</url>
    <content type="text"><![CDATA[Beck Design Rules （Beck设计规则 A生译） Kent Beck developed Extreme Programming, Test Driven Development, and can always be relied on for good Victorian facial hair for his local ballet. 作者 : Martin Fowler译者 : A生原文地址 Kent Beck 归纳出他关于简单设计的四条规则，当他在1990年代发明极限编程的时候。 我将它们概括如下： 通过测试 展现意图 没有重复 极少的元素 规则是按优先级排序的，所以 “通过测试” 比 “展现意图” 有着更高的优先级。 最重要的规则就是 “通过测试”。XP（极限编程）是关于测试如何在软件开发中上升为一等活动的革命，所以自然地，它应该在那些规则之中扮演着尤其显要的角色。关键点是无论你在软件中干了什么，主要目的是让它如心中所想那样的工作，测试在哪里就是确保它是那样的发生。 “展现意图” 是Kent的方式去说明代码应该容易被理解。沟通是极限编程的核心价值，很多程序员喜欢这样的认为：程序在哪里就是为了被别人去阅读的。Kent解释这个规则的关键是，能够在代码里去表达你的意图，所以你的读者能够理解你当时写下那段代码的目的。 “没有重复”可能是那些规则中最有力和微妙的。它在别的地方也叫做 “DRY” or “SPOT” [备注] 的概念,Kent表达它是关于当说起所有的事情时，应该是“一次 只有一次”。许多程序员已经注意到，去除重复是演进好的设计的一种的强力方式。 最后一条规则告诉我们，任何不服务前面三条规则的，都应该被移走。当这些规则制定的同时，许多设计上的建议是：为了能够增加对未来需求的灵活性，在一个架构上不断地增加元素。具有讽刺意义的是，所有这些元素带来的额外的复杂性，让系统难于修改，因此在实践中的灵活性就更少了。 人们常常会发现 “没有重复”和“展现意图” 之间有一些争议，导致争论的是这2个规则的优先次序。我经常觉得他们之间的顺序并不重要，因为他们彼此在精炼代码的过程中相互依存。诸如通过增加重复的内容来让代码更加清晰，往往是正在准备去掩盖一个问题，当这个问题将被更好的解决的时候。 我喜欢这些规则的是记住它们很简单，遵循这些规则可以改进任何一种我用过的语言或编程的范式。它们是Kent寻找普遍适用的原则的能力的其中一个例子，但足以改变我的行为。 At the time there was a lot of “design is subjective”, “design is a matter of taste” bullshit going around. I disagreed. There are better and worse designs. These criteria aren’t perfect, but they serve to sort out some of the obvious crap and (importantly) you can evaluate them right now. The real criteria for quality of design, “minimizes cost (including the cost of delay) and maximizes benefit over the lifetime of the software,” can only be evaluated post hoc, and even then any evaluation will be subject to a large bag full of cognitive biases. The four rules are generally predictive. 当有很多 “ 设计是主观的 ”,“ 设计是一种品味 ” 废话的时候。我不同意，设计有更好的和更糟糕的。这些标准并不完美,但是它们解决了一些明显的废话，(重要的是)现在你可以评估他们。这四个规则通用地评估：质量设计的真正标准， “ 最小化成本(包括延迟的成本)和最大化效益在软件的生命周期 ” 。而不是那些只能事后评估,甚至任何评估了就将受到一大堆认知偏见的评估。 – Kent Beck Further Reading原文地址 备注＊DRY stands for Don’t Repeat Yourself, and comes from The Pragmatic Programmer.SPOT stands for Single Point Of Truth.]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Fear of Death]]></title>
    <url>%2F2015%2F05%2F01%2FTao-2015-2015-05-01-theFearOfDeath%2F</url>
    <content type="text"><![CDATA[死亡的恐惧 最近有个朋友问我，要如何才能面对死亡的恐惧。 好吧，其实这个问题，从我懂事以来就常在思考。当你意识到，人出生的时候就注定了死亡，自己也会死的时候，会不会觉得整个世界都不会好了呢？ 那么，自古以来，人们都怎么克服对死亡对恐惧，而微笑地活下去地呢？ 我能想到的，无非是以下几种： #遗忘遗忘大概是最多人采取的策略。在日常时候生活里，意识会假装死亡并不存在，从而无惧地生活下去。 #宗教如果经历过身边的人的死亡，那么遗忘策略可能就不那么奏效了。这个时候，宗教就出现了。在多数的宗教里，死亡并不是终点，而是试炼的一部分。有些宗教通过复活来解决，有些宗教通过轮回来解决，有些则通过创造来天堂和地狱来分流不同的羔羊。宗教的好处是你可以不用思考，只要怀着虔诚地追寻： 一位先知，一个预言，一部经书，一个启示。 #哲学当然也有一些不相信宗教的人，那么，他们该如何来克服自己对死亡的恐惧呢？答案是构筑一个自己可以信服的理论来接受死亡，我们通常称之为哲学。 学哲学就是为了学死。 我在某本哲学书里看到的，关于哲学和死亡，最为印象深刻的一句话。哲学的流派也分好多，唯心的，唯物的，辩证的，等等，我就不一一介绍了。 #忙碌以上几种都算比较积极的方法。接下来就是较为消极的方法了： 有些人选择让自己一直处于忙碌的状态，这样就没空去想这个问题。 仿佛一只把头埋在沙里的鸵鸟，外面发生的事情，与我无关。 #拥抱最为消极的方法，莫过于直接地去拥抱死亡了。无法逃避，无法接受，最终只能选择自杀了。 #结论以上的种种胡言，都属于我当下这个时刻的想法。以前我会害怕自己下的结论不够准确，不够全面。现在我就不会了，因为我所说的，我所想的，都是我现有水平的结果。以后肯定会变，随着时间，随着眼界的变化。否定之否定，人才能不断地前进。 当然，当我自己面对死亡的时候： 该崩溃的时候，还是会崩溃。]]></content>
      <categories>
        <category>Tao</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ Tips]]></title>
    <url>%2F2015%2F04%2F17%2FTech-2015-2015-04-17-IntelliJTips%2F</url>
    <content type="text"><![CDATA[IntelliJ Tips 从RAD切换到IntelliJ已有一段时间，学习曲线总的来说，还不是很高。直到我从windows换到Mac系统，一些奇怪到问题也出现了。 忽然失效的SpringUnitTest对我这种不写测试就写不了代码的码农来说，没什么比测试用例突然运行不了更打击人的了。万万没想到，切换到高大上到mbp之后，IntelliJ的SpringUnitTest就跑不起来了。 看了一下日志，原因是SpringJUnit4ClassRunner无法读取配置文件的路径。在win系统下Eclipse和IntelliJ工作的正常的代码如下： 123456@RunWith(SpringJUnit4ClassRunner.class)@ActiveProfiles("test")@ContextConfiguration(locations = &#123;"classpath:applicationContext*.xml"&#125;)public class Test &#123;...&#125; 经过一系列的排查和祈祷（囧），问题出在mac版的IntelliJ无法通过 通配符 ＊ 去载入所有的配置文件。修改如下： 123456789@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123; "classpath:applicationContext.xml", "classpath:applicationContext-IoC.xml", "classpath:applicationContext-persistence.xml"&#125;)@ActiveProfiles("test")public class Test &#123;...&#125; 问题是解决了，具体的因果要深入到IDE的内部工作原理才行了。我最近学会了一件事，不要凡事都非要求个因果。 ：） ps： 最终还是完美解决了这个问题：123456@RunWith(SpringJUnit4ClassRunner.class)@ActiveProfiles("test")@ContextConfiguration(locations = &#123;"classpath*:applicationContext*.xml"&#125;)public class Test &#123;...&#125; classpath 后面必须加多个*， 在Spring 文档有提到，不过win平台没有这个问题。。 Other notes relating to wildcards Please note that “ classpath:” when combined with Ant-style patterns will only work reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern like “ classpath:*.xml” will not retrieve files from the root of jar files but rather only from the root of expanded directories. This originates from a limitation in the JDK’s ClassLoader.getResources() method which only returns file system locations for a passed-in empty string (indicating potential roots to search). Ant-style patterns with “ classpath:” resources are not guaranteed to find matching resources if the root package to search is available in multiple class path locations. This is because a resource such as com/mycompany/package1/service-context.xmlmay be in only one location, but when a path such as classpath:com/mycompany/*/service-context.xmlis used to try to resolve it, the resolver will work off the (first) URL returned by getResource(“com/mycompany”);. If this base package node exists in multiple classloader locations, the actual end resource may not be underneath. Therefore, preferably, use “ classpath:” with the same Ant-style pattern in such a case, which will search all class path locations that contain the root package.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kettle Tips]]></title>
    <url>%2F2015%2F04%2F03%2FTech-2015-2015-04-03-KettleTips%2F</url>
    <content type="text"><![CDATA[Kettle Tips Kettle作为一个开源的ETL工具，功能也算挺齐全的，当然坑也不会少。：）so A生也小小的分享一下遇到的其中一些坑。 解决中文乱码问题DB 链接处设置： characterEncoding=utf8; characterSetResults=utf8; useUnicode=true 去掉简易设置的选项： 更新修改过的表结构清除DB的缓存 使用变量变量名字不能与Job/Trans命令参数同名，否则变量读取会失效。 变量引用格式 ： ${param} 去掉自动增加的小数点输入输出字段定义格式 Kettel 系统配置文件在第一次运行kettle之后，kettle会在%HOME_USER_FOLDER%菜单里面创建一个 .kettle文件夹， windows C:\Documents and Settings\${your user name}.kettle\kettle.propertieslinux /home/${your user name }/.kettle/kettle.properties 命令行运行Job/TransJob./kitchen.sh -file=? -debug=debug -log=log.logTrans./pen.sh -file=? -debug=debug -log=log.log]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Agile and Lean]]></title>
    <url>%2F2015%2F01%2F01%2FArt-2015-2015-01-01-AgileAndLean%2F</url>
    <content type="text"><![CDATA[敏捷与精益 近期读了2本关于敏捷开发的书, 《敏捷开发一千零一夜》和《精益开发实战》.回想起以前读过的所有关于敏捷和精益的书,感触良多。一千零一夜的第六章:”从敏捷到精益” 和第十一章：“敏捷无它，持续改进” 于我的共鸣是最多的。 Do Right Thing vs. Do Thing Right如果没有在做：“正确的事情”，越是“正确地做事”，就越是错的多，因为他们浪费就更多。 只有敏捷是不够的敏捷不是银弹，其实这个世界很残酷，并不是掌握了什么就能一帆风顺的。掌握知识是很重要，何时用，怎么用，对于每个人来说都不可能像看着菜谱煮菜那么简单。只有Scrum是不行的，如果只有Scrum。单单靠敏捷是不够的，结合精益能够增加多些成功的机会。 TDD的精神TDD是XP的基础,也是敏捷的基础,同时TDD的精神也是精益创业的基础.测试驱动,快速得到反馈,迅速做出调整就是TDD的精神.基本步骤: 提出需要验证的前提假设 建立观测数据指标 开发最小可行产品 收集数据验证假设 我把TDD当做程序员的分水岭,TDD不只是关于测试,更是关于设计. 道与术技术牛人有两种, 精通”道”的与精通”术”的.道是形而上的,是关于抽象的能力.术是形而下的,是关于具象的能力. 面向对象设计的能力,TDD的能力都是关于”道”的.熟练掌握各种工具和语言的, 则是”术”上的高人. 好的程序员是 “道” “术”双修的. :) 架构Uncle Bob大叔 : 架构无非是设计中不可逆的部分. Martin Folwer : 架构师有2种: 传统的架构师,非常厉害的做了很多&quot;大&quot;的设计（架构），他的设计可逆性很差，尽管合情合理。另外一种架构师尽量增强可逆性，哪怕是很大的设计。 架构师做2件事： 建立架构，消灭架构。You are what you do 。 裸奔的领域模型用户不关心你的“解决方案”，用户关心他们的“问题”。 领域层封装客户的业务需求,日常业务规则,我们开发软件的目的就是解决他们的需求.UI是可变的,存储逻辑也是可以换掉的,业务逻辑才是我们的核心。所以领域模型必须裸奔，不依赖其它层。通过IOC或者六边形架构可以解决依赖的问题。 问题与解决方案 ，5个why很多开发团队非常容易犯的错误，他们激烈的讨论某一个技术问题如何实现，却不知道背后的用户逻辑。 问题和解决方案是一对多的。 不要沉溺于技术问题，要时时记得用户的问题。 Scrum里的User Story背后就隐藏这样的智慧： As a （who）， i want （what）， in orderto （why） 最后的why就是用于描述用户的问题或者业务需求。 估算的过程很有帮助，估算的结果往往没有。团队估算是为了打破鸿沟，它会把团队成员的假想暴露出来，通过暴露假想来发现更多的问题。 觉得浪费时间，让一个人去做这些事情，完成估算，拆好任务，贴在板上，完毕？呵呵。]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hex Architecture]]></title>
    <url>%2F2014%2F11%2F20%2FArt-2014-2014-11-20-HexArchitecture%2F</url>
    <content type="text"><![CDATA[六边形架构第一次看到六边形架构,是从《IDDD》这本书里看到的,当时就觉得这是和DDD相当match的架构.稍微研究了下,发现Alistair Cockburn这篇《Hexagonal Architecture》详细地介绍什么是六边形架构,按照惯例, A生假假地的翻译了一下. 六边形架构作者 : Alistair Cockburn译者 : A生 创建一个既不需要UI也不需要DB就能工作的应用程序,那样你就能针对它去运行自动化的回归测试,即使DB挂了也能继续工作,不需要任何用户参与,就能和其他应用程序连接起来. 模式: 端口与设配器 (“对象结构”) 别名 : 端口与设配器别名 : 六边形架构 意图允许一个应用程序平等地被用户,程序,自动化测试和批处理脚本所驱动,可被单独开发和测试于最终运行时的设备和数据库. 从外面世界进来的事件到达某一个端口,一个技术意义上的设配器把它转换成一个过程调用或消息后传入应用程序.应用程序幸福地忽略输入设备的本来面目.当应用程序发送某些东西出去时,它通过某个端口发送至某个设配器,去创建被接收技术方(人工或自动)所需要的适当的信号.应用程序从语义上通过适配器和各处交互,而不需要去知道设配器另一端的本来面目. 特性 1动机这些年来软件应用程序里最大的问题之一,就是把业务逻辑渗透在用户接口的代码里.由此引起的问题有三部分: 第一,系统不能被自动化测试套件整洁地测试,因为部分需要被测试的逻辑依赖经常变化的可视化细节,如字段长度和按钮位置等; 因为同样的原因,它变得不可能从一个人肉使用的系统变成一个批处理的系统; 还是同样的原因,当系统开始受欢迎的时候,它变得困难或不可能去允许该程序被另外的程序所驱动. 在许多组织里重复的,一种尝试了的解决方案,就是创建一个分层的架构.在那个时候去承诺,真心诚意地去承诺,没有业务逻辑会放到新的分层里.但是,当发生了破坏承诺的时候,却没有一种机制能够检测出.组织会发现若干年后,新的分层和业务逻辑混在一起,老问题又再次出现了. 现在想象应用程序提供的“每一片”功能，是以API（application programmed interface) 或函数调用的形式出现。在这种情况下，当任何新的代码破坏现有可工作的功能的时候，测试或QA部门可通过运行自动化测试脚本来针对应用程序去发现问题。业务专家可以在GUI细节最终确定之前，创建自动化测试用例，去告诉程序员，什么才是他们的工作正确完成的时候。（那些测试由测试部门来运行）。应用程序可用“headless”模式去部署，所以只有API是有效的，其他的程序可利用它的功能——简化了整个复杂系统套件的设计，同时也许可了每一个Web上无需人介入的“business-to-business”的应用服务。最后，自动化了功能上的回归测试，检测出了任何违背了把业务逻辑放在表现层之外的承诺。组织可以检测和修正逻辑泄露。 另外一个类似的有趣问题，什么是被认为是正常的应用程序的“另一边”，那里是应用程序逻辑被绑定在外部的数据库或设备？当数据库服务器停机或进行重大的修订或替换时，程序员就不能继续工作，因为他们的工作绑定在数据库上。这会导致延迟成本和人们会经常感觉到很糟糕。 以上2个问题看起来不是很明显的相关，但它们在自然的解决方案中却显现出了对称性。 自然的解决方案客户端和服务器端两边的问题都是因为设计和编程上的同一个错误——业务逻辑和与外部实体交互之间的纠缠不清。不对称的探索，不是在应用程序的“左边”和“右边“之间，而是应该在应用程序的”内部“和”外部“之间。这样的规则履行了与”内部“相关的代码不应该泄露到”外部“去。 暂时移除任何左右或上下的不对称，我们看到了应用程序通过“端口”与外部代理们沟通。“端口”一词应会引起联想到操作系统层面的端口，任何设备都可以插入使用某种协议的端口那里。同样道理，“端口”在电子产品那，任何设备只要符合规格，都可以插入电子产品里。 端口的协议就是为了两个设备之间的会话。 这样的协议以API的形式出现。 每一个外部设备都有一个“设配器”，把API所定义的信号转换到设备所需要的，反之亦然。一个图形化的用户接口或GUI就是一个设配器的例子，映射了一个人在API端口上的动作。其他的设配器在同一个端口上则是自动化测试的安全带，例如FIT或Fitnesse，批处理驱动器，和任何为了应用程序和整体或网络之间沟通的代码。 在应用程序的另一边，应用程序通过与外部实体沟通来获得数据。数据库协议就是一种经典的协议。从应用程序的角度，如果数据库从一个SQL数据库迁移到一个扁平的文件或其他类型的数据库，通过API的转换应该没有改变。在同一个端口上增加的设配器应该包括一个SQL设配器，一个文件设配器。最重要的，一个去连接到“mock”数据库，一个停留在内存里和完全不依赖真正数据库的设配器。 许多应用程序只有2个端口：客户端的对话和数据库端的对话。这让他们以不对称的形式出现，从而让看起来像是创建一个一维的，3/4/5层的架构的应用程序。 这样的图纸会有2个问题。第一、并且是最坏的情况，人们通常不会认真地对待分层中的“边界线”。他们会让应用程序的逻辑泄露在层级边界之外，导致以上所说的问题。第二、应用程序可能会有超过2个以上的端口，所以架构上并不对应一维的层设计。 六边形(或端口与设配器)架构通过在这种情况下注意到对称性来解决了这些问题：一个应用程序在内部，通过某些端口与外界的东西交互。应用程序外面的东西能够尽早地去处理对称性。 六边形有意在视觉上突出 (a) 内外的对称性和相似自然的端口,摆脱了一维层视图和所有的调用,和(b) 不同端口定义的存在数量——2,3 或4个 (4个是我最常遇到的) 六边形不是六边的是因为数字6很重要,而是允许人们进行绘制是有空间去放入他们所需要的端口和设配器,不限制于一维层次的绘制。术语“六边形架构”是来自可视化的效果。 术语“端口与设配器”拾起了部分绘制的“目的”。端口定义了有目的的会话。通常会有多个设配器对应一个端口，为了多样的技术可插入端口内。 有代表性的，它们可以包括一个电话机器应答，一个人工应答，一个按键式电话，一个图形化人机界面，一个测试装置，一个批处理驱动器，一个http接口，一个程序到程序的接口，一个mock（内存内）数据库，一个真正的数据库（可能有不同的数据库用于开发。测试和实际使用）。 在应用程序里，左右不对称将再次带出来，无论如何，这个模式的主要目的是集中于内外不对称，从应用程序的角度，假装短暂地识别所有的外面组件。 结构 特性 2特性2显示了一个应用程序有着2个活动端口和用于同一个端口多个设配器。那2个端口分别是应用程序控制方面和数据检索方面。这样的绘制显示出应用程序可以被平等地驱动于：一个自动化、系统级别的回归测试套件，一个人类用户，一个远程的http应用程序，或者另一个应用程序。在数据方面，应用程序从外部数据库解耦，可以被配置运行在一个内存内的Oracle，或“mock”，数据库替换者；或者它可以运行在针对测试的或运行时的数据库。应用程序功能上的规格，或许在用例内，是针对与六边形内部的接口，而不是针对任何一个外部的技术可能用到的接口。 特性 3特性3显示出同一个应用程序对应一个三层架构绘制。每一个端口简化到只有2个适配器。这样的绘制趋势于去显示，多个适配器怎样去适应于顶层和低层，和在开发系统中被用到的，多个适配器之间的序列。编号的箭头显示出一个团队和应用程序可能会用到的次序： 用于被应用程序驱动的一个FIT测试设备和用着取代真正数据库的mock（内存内）数据库； 增加一个GUI到应用程序，仍然跑在mock数据库。 在集成测试里，针对于一个真正包含测试数据的数据库，运行自动化测试脚本（如从Cruise Control）去驱动应用程序。 真正地去使用，一个人通过应用程序去访问真正的数据库。 样例代码幸运地可以通过FIT的文档，一个最简化应用程序去演示端口与适配器。它是一个简单的折扣计算的应用程序： 1discount(amount) = amount * rate(amount); 在我们的程序里，amount会来自用户和rate会来自一个数据库，所以那里会有2个端口。我们实现它们在以下步骤： 测试取代mock数据库的一个固定的rate 然后是GUI 然后是一个可被切换到真正数据库的mock数据库 感谢在IHC的Gyan Sharma 提供这个例子的代码。 步骤1： FIT App constant-as-mock-database首先我们创建测试用例通过一个HTML table(看FIT文档如下): TestDiscounter amount discount() 100 5 200 10 注意列名会变成class和function名字在我们的应用程序里。FIT包括了摆脱这种“programmerese”的道路，但是为了这篇文章会简单地把它们放进来。 知道了那些会是测试的数据，我们创建用户边的设配器，来自FIT里的ColumnFixture如下： 12345678import fit.ColumnFixture; public class TestDiscounter extends ColumnFixture &#123; private Discounter app = new Discounter(); public double amount; public double discount() &#123; return app.discount(amount); &#125; &#125; 实际上那里的所有都是到设配器的，目前为止，测试可从命令行里运行（看FIT的书会有你所需要的路径）。我们使用这个： 123set FIT_HOME=/FIT/FitLibraryForFit15Feb2005java -cp %FIT_HOME%/lib/javaFit1.1b.jar;%FIT_HOME%/dist/fitLibraryForFit.jar;src;binfit.FileRunner test/Discounter.html TestDiscount_ FIT 生产出一个导出的文件，通过颜色告诉我们那些测试通过了（或者失败，唯一我们在过程中从那里打错了） 在这个点上的代码已经准备好去check in，集成在Cruise Control或你自己的自动化构建机器里，包括在构建-测试套件里。 步骤2： UI App constant-as-mock-database我会让你去创建属于你自己的UI和让它驱动Discounter应用程序，因为代码放在这里有点过长，某些关键的代码如下： 12345678910 ... Discounter app = new Discounter();public void actionPerformed(ActionEvent event) &#123; ... String amountStr = text1.getText(); double amount = Double.parseDouble(amountStr); discount = app.discount(amount)); text3.setText( "" + discount ); ... 在这个点上的代码可以去被演示和回归测试。用户端的设配器都已运行中。 步骤3： (FIT or UI) App mock database去创建一个可替换的数据库端的设配器，我们为一个仓储创建一个“接口”，一个“RepositoryFactory” 会生产出要么模拟数据库、要么真正的服务的对象，在内存里去模拟数据库。 123456789101112131415161718192021public interface RateRepository &#123; double getRate(double amount); &#125;public class RepositoryFactory &#123; public RepositoryFactory() &#123; super(); &#125; public static RateRepository getMockRateRepository() &#123; return new MockRateRepository(); &#125;&#125;public class MockRateRepository implements RateRepository &#123; public double getRate(double amount) &#123; if(amount &lt;= 100) return 0.01; if(amount &lt;= 1000) return 0.02; return 0.05; &#125; &#125; 挂钩这个设配器到Discounter应用程序内，我们需要更改下应用程序自身，去接受使用一个repository设配器，和让（FIT / UI）用户端的设配器传入repository去使用（real or mock）到应用程序的构造函数里。这里有已更改的应用程序和一个FIT设配器传入一个模拟的repository。（FIT设配器的代码，选择是否传入到模拟或真实repository的设配器里，在没有增加太多新的信息情况下有点过长，所以我在这里省略的那个版本） 12345678910111213141516171819202122232425262728import repository.RepositoryFactory;import repository.RateRepository;public class Discounter &#123; private RateRepository rateRepository; public Discounter(RateRepository r) &#123; super(); rateRepository = r; &#125; public double discount(double amount) &#123; double rate = rateRepository.getRate( amount ); return amount * rate; &#125;&#125;import app.Discounter;import fit.ColumnFixture;public class TestDiscounter extends ColumnFixture &#123; private Discounter app = new Discounter(RepositoryFactory.getMockRateRepository()); public double amount; public double discount() &#123; return app.discount( amount ); &#125;&#125; 那样就包括了实现六边形架构的最简单的版本。 另外一个不同的实现，使用Ruby和Rack为了浏览器使用，详情：https://github.com/totheralistair/SmallerWebHexagon 应用程序指南左右不对称端口和设配器模式是故意把所有的端口都写上去像是从根本上是相似的。那样的假装在架构层面是有用的。在实现阶段，端口和设配器显示出2种风味，我将其称之为“主要的”和“次要的”，理由很快会揭晓。它们可称之为“驱动”设配器和“被驱动”设配器。 警觉的读者会注意到所有已给的例子里，FIT fixtures是用了左边端口而mock在右边。在三层的架构里，FIT 坐落在顶层而mock坐落在底层。 相关的主意是来自“主角”和“次角”的例子。“主角”是驱动了应用程序（改变静止的状态和执行某个已知的功能）。“次角”是被应用程序所驱动的，无论是从中获取应答还是仅仅是通知。“主角”和“次角”的差别是在于谁触发了或者是负责了会话。 FIT是代替主角的自然测试设配器，从框架设计成读取一个脚本和驱动应用程序开始。mock是代替了“次角”的自然测试设配器，从被设计成从应用程序里去应答查询和记录事件开始。 这些观察带领我们服从系统的用例上下文图，和在六边形的左边（或顶层）去绘制“主要端口”和“主要适配器”，在六边形的右边（或底层）去绘制“次要端口”和“次要适配器”。 主次要端口和设配器之间的关系，和他们在FIT和mock的各自实现，记在脑子里是有用的，但应该是用来作为使用端口和设配器架构的结论，而不是简化之。实现端口和设配器的最终好处从一个完全隔离模式敏捷地去运行应用程序。 用例和应用程序边界使用六边形架构模式是有用地去加强，编写用例的首选模式。 编写用例通常会犯的错误是，在每个端口外面包含了亲密的技术知识。在行业里这种用例获得了众所周知的坏名声，变得冗长，难读，沉闷，易碎，维护昂贵。 理解端口和设配器模式，我们可以看到用例一般应该写在应用程序边界内（六边形内部），去指定被应用程序所支持的功能和事件，不去管外部的技术。这样用例是简短，易读，更少维护成本，和在时间上更加稳定。 多少端口？到底什么是或不是端口，很大程度上只是口味的问题。在极端的情况下，每一个用例只有自己的端口，为了许多的应用程序提供了上百个端口。另外的一种选择，可以想象把所有的主要端口和次要端口融合在一起，到那时3只有2个端口，左边的和右边的。 没有最好只有更好。 已知应用的天气预报系统有着4个自然的端口：天气反馈，管理员，通知用户，用户数据库。咖啡售卖机的有4个自然的端口：用户，包括食谱和价格的数据库，售卖机，和硬币箱子。医院的药物系统可能有3个：一个给护士，一个给药方数据库，一个给控制药物分配器。 选择“错误”数量的端口数不见得会有任何特殊的坏处，所以保持一种直觉即可。我倾向于选择少量的数目，2,3或4，如上所述和已知应用。 已知应用 特性 4特性展现一个有着4个端口并且每个端口都有多个设配器的应用程序。这是从一个应用程序衍生出的监听来自国家天气服务的警报，关于地震，龙卷风，火灾和水灾。和通知人们通过他们的电话或电话对讲机。在我们讨论这个系统的时候，这个系统的接口已确认，从“技术，连接的目的”上讨论过。那里有一个接口为了接收电线上的触发数据，一个为了把通知数据发送到对答的机器上，一个GUI实现的管理接口，和一个获取用户数据的数据库接口。 人们正在努力，因为他们需要从天气服务增加一个http接口，一个email接口给他们的用户，和他们不得不寻找一种方式可以为了不同的客户采购偏好，绑定和解绑他们增长着的应用程序套件。他们害怕停留在一个维护和测试的噩梦里，因为他们不得不实现，测试和维护所有独立的组合和排列的版本。 他们修改了设计，在系统接口上根据“目的”而不是根据“技术”去架构，让技术通过设配器变得可以替换（所有方面的）。他们立马提高了速度去包含http订阅和email通知（新的设配器通过虚线绘制出来）。通过APIs让每个应用程序在headless模式下运行，他们可以增加一个 app-to-add 的设配器和解除绑定应用程序套件，按需连接子应用程序。最后，让每一个应用程序可完全独立的执行，通过内置的测试和mock设配器，他们获得了敏捷的通过独立的自动化测试脚本去回归测试他们的应用程序。 Mac, Windows, Google, Flickr, Web 2.0早在1990时，MacIntosh应用程序如文档处理软件就需要有API驱动的接口，所以应用程序和用户编写的脚本就可以访问应用程序的所有的功能。Windows桌面软件有着同样的能力。（我没有对应的历史知识去说谁先出现，反正那也不是重点） 如今（2005）web软件的趋势是发布一个公共API去让别的软件直接的访问那些APIs。虽然，那可能会通过google map去发布一些犯罪的数据，或者创建web应用程序包括Flickr在内的相片存档和注释的能力。 所有的这些例子都是关于把“主要的”端口的API可视化， 我们看不到任何信息在次要端口。 Stored OutputsWillem Bogaerts在C2 wiki上写下这个例子：“我遇到过类似的事情，但是主要是因为我的应用程序层有很强的趋势去变成一个电话切换板去管理它不应该去做的事情。我的应用程序产生输出，显示给用户和有可能会去保存好它。我主要的问题是你不需要常常去储存它。所以我的应用程序产生输出，不得不缓存它和展现给用户。然后，当用户决定要保存导出的数据时，应用程序清空缓冲和真正的保存它。 我一点都不喜欢这个，于是我想出了一个解决方案：有一个带存储功能的展现控制器。现在应用程序不再需要管道输出到不同的方向，只是简单地输出到展现控制器。展现控制器缓冲了结论和给用户去保存它的可能性。 传统的架构分层强调“UI”和“存储”是不同的。端口和设配器模式架构可以再简化输出到简单的“输出”。” 来自C2-wiki的匿名例子“在我做过的一个项目里，我们使用“真音响设备”的系统隐喻。每一个组件定义了接口，每一个接口都有不同的目的。我们几乎可以通过连线和设配器，没有限制的把组件们连接在一起” 分布式，大团队开发这个还在实验阶段的使用和还不能恰当地评估这个模式的使用情况。无论如何，那个很有意思去考虑的。 不同位置的团队们全去构建六边形架构，用着FIT和mocks，所以应用程序和组件可以独立模式下去测试。CruiseControl每半个小时去运行构建和使用FIT+mock的组合去运行所有的应用程序。因为应用程序子系统和数据库已完整地，替换成mock和测试数据库了。 独立的开发UI和应用程序逻辑这个还在早期的实验阶段的使用和还不能恰当地评估这个模式的使用情况。无论如何，那个很有意思去考虑的。 UI设计是不稳定的，因为它们还未定好是那一种驱动的技术或隐喻。后端服务架构没有定好，事实上它可能在半年内经历过几次改变。尽管如此，项目却是正常地启动和时间是滴答作响的。 应用程序团队创建FIT测试和mocks去隔离他们的应用程序，创建可测试的，可演示的功能展示给他们的用户。当UI和后端服务最终决定时，它“一个直接的”增加那些元素到应用程序里。开始学习怎样实现它。（或你自己尝试下和写邮件给我） （A生注： 相关模式、感谢和其他引用就不再翻译拉～～ ：） ） Related PatternsAdapterThe ‘’Design Patterns’’ book contains a description of the generic ‘’Adapter’’ pattern: “Convert the interface of a class into another interace clients expect.” The ports-and-adapters pattern is a particular use of the ‘’Adapter’’ pattern. Model-View-ControllerThe MVC pattern was implemented as early as 1974 in the Smalltalk project. It has been given, over the years, many variations, such as Model-Interactor and Model-View-Presenter. Each of these implements the idea of ports-and-adapters on the primary ports, not the secondary ports. Mock Objects and Loopback“A mock object is a “double agent” used to test the behaviour of other objects. First, a mock object acts as a faux implementation of an interface or class that mimics the external behaviour of a true implementation. Second, a mock object observes how other objects interact with its methods and compares actual behaviour with preset expectations. When a discrepancy occurs, a mock object can interrupt the test and report the anomaly. If the discrepancy cannot be noted during the test, a verification method called by the tester ensures that all expectations have been met or failures reported.” — From http://MockObjects.com Fully implemented according to the mock-object agenda, mock objects are used throughout an application, not just at the external interface The primary thrust of the mock object movement is conformance to specified protocol at the individual class and object level. I borrow their word “mock” as the best short description of an in-memory substitute for an external secondary actor. The Loopback pattern is an explicit pattern for creating an internal replacement for an external device. PedestalsIn “Patterns for Generating a Layered Architecture”, Barry Rubel describes a pattern about creating an axis of symmetry in control software that is very similar to ports and adapters. The ‘’Pedestal’’ pattern calls for implementing an object representing each hardware device within the system, and linking those objects together in a control layer. The ‘’Pedestal’’ pattern can be used to describe either side of the hexagonal architecture, but does not yet stress the similarity across adapters. Also, being written for a mechanical control environment, it is not so easy to see how to apply the pattern to IT applications. ChecksWard Cunningham’s pattern language for detecting and handling user input errors, is good for error handling across the inner hexagon boundaries. Dependency Inversion (Dependency Injection) and SPRINGBob Martin’s Dependency Inversion Principle (also called Dependency Injection by Martin Fowler) states that “High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.” The ‘’Dependency Injection ‘’pattern by Martin Fowler gives some implementations. These show how to create swappable secondary actor adapters. The code can be typed in directly, as done in the sample code in the article, or using configuration files and having the SPRING framework generate the equivalent code. AcknowledgementsThanks to Gyan Sharma at Intermountain Health Care for providing the sample code used here. Thanks to Rebecca Wirfs-Brock for her book ‘’Object Design’’, which when read together with the ‘’Adapter’’ pattern from the ‘’Design Patterns’’ book, helped me to understand what the hexagon was about. Thanks also to the people on Ward’s wiki, who provided comments about this pattern over the years (e.g., particularly Kevin Rutherford’s http://silkandspinach.net/blog/2004/07/hexagonal_soup.html). References and Related ReadingFIT, A Framework for Integrating Testing: Cunningham, W., online at http://fit.c2.com, and Mugridge, R. and Cunningham, W., ‘’Fit for Developing Software’’, Prentice-Hall PTR, 2005. The ‘’Adapter’’ pattern: in Gamma, E., Helm, R., Johnson, R., Vlissides, J., ‘’Design Patterns’’, Addison-Wesley, 1995, pp. 139-150. The ‘’Pedestal’’ pattern: in Rubel, B., “Patterns for Generating a Layered Architecture”, in Coplien, J., Schmidt, D., ‘’PatternLanguages of Program Design’’, Addison-Wesley, 1995, pp. 119-150. The ‘’Checks’’ pattern: by Cunningham, W., online at http://c2.com/ppr/checks.html The ‘’Dependency Inversion Principle’‘: Martin, R., in ‘’Agile Software Development Principles Patterns and Practices’’, Prentice Hall, 2003, Chapter 11: “The Dependency-Inversion Principle”, and online at http://www.objectmentor.com/resources/articles/dip.pdf The ‘’Dependency Injection’’ pattern: Fowler, M., online at http://www.martinfowler.com/articles/injection.html The ‘’Mock Object’’ pattern: Freeman, S. online at http://MockObjects.com The ‘’Loopback’’ pattern: Cockburn, A., online at http://c2.com/cgi/wiki?LoopBack ‘’Use cases:’’ Cockburn, A., ‘’Writing Effective Use Cases’’, Addison-Wesley, 2001, and Cockburn, A., “Structuring Use Cases with Goals”, online at http://alistair.cockburn.us/crystal/articles/sucwg/structuringucswithgoals.htm]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[The Little Mocker]]></title>
    <url>%2F2014%2F10%2F14%2FArt-2014-2014-10-14-TheLittleMocker%2F</url>
    <content type="text"><![CDATA[The Little Mocker 关于Mock和Stub之间的区别，我一直没搞明白。 直到看了Uncle Bob的The Little Mocker ，才知道里面的水还挺深的，我姑且尝试把它翻译一下： 小Mocker作者:Uncle Bob译者:A生 接下来的讨论是关于mocking： 这是什么？ 123interface Authorizer &#123; public Boolean authorize(String username, String password);&#125; 一个interface. 那么这样呢? 12345public class DummyAuthorizer implements Authorizer &#123; public Boolean authorize(String username, String password) &#123; return null; &#125;&#125; 那是Dummy 那你拿Dummy做什么呢? 你把它传入某地方,但你并不在意怎么用它的时候. 就像? 作为测试的一部分,当必须要传入一个参数,但你知道那个参数永远不会用到的时候. 能举个例子么? 当然. 123456789101112131415public class System &#123; public System(Authorizer authorizer) &#123; this.authorizer = authorizer; &#125; public int loginCount() &#123; //returns number of logged in users. &#125; &#125; @Test public void newlyCreatedSystem_hasNoLoggedInUsers() &#123; System system = new System(new DummyAuthorizer()); assertThat(system.loginCount(), is(0)); &#125; 我懂了.为了能构造系统,必须传入一个Authorizer到构造函数里;但authorize方法永不会被调用到,所以在这个测试里,没有人会登陆入. 你懂的. 所以DummyAuthorizer的authorize方法返回一个null并不是一个错误. 其实不是.事实上,一个Dummy最好能有所返回. 为什么呢? 因为任何人尝试用这个Dummy,他们会得到一个NullPointerException. 啊,你不想这个Dummy被使用. 对!它只是一个dummy. 但这不是一个mock?我以为那些测试对象叫做mocks. 它们是;但那是行话. 行话? 是的,”mock”这个词汇,有时被用于一种非正式的场合,用来代表测试对象的整个家族. 那么这些测试对象们有一个正式的名字么? 有,它们叫做”Test Doubles” [1]. 你指像电影里的”替身”么? 必须滴. 那么”mock”这个词只是通俗的行话? 不,它也有一个正式的含义;但当我们非正式说mock时,它是Test Double的同义词. 为什么我们得有2个词?不能只用Test Double代替Mock么? 历史原因. 历史? 是的,很久之前某个很聪明的人写了一篇文章来介绍和定义什么Mock对象.很多人读过并且开始使用这个词.没有读过的人听到这个词,也开始广义地使用.他们甚至把它变成动词,他们会说:”让我们mock那个对象吧”,或 “我们有很多的mocking要做”. 很多词汇都发生过类似的事情,不是么? 的确是的.特别是当一个词只有一个音节,那是容易说出的. 耶，我猜那会容易说些：“让我们mock它吧” 而不是 “让我们为此做个测试替身吧”. 对, 口语是生活的一种现实. OK,但我们需要精确的说呢… 那你应该用正式的语言. 那什么是Mock呢? 在我们说那之前,我们应该看下其他种类的测试替身. 比如? 先看下Stubs 什么是stub? 这,就是一个stub: 12345public class AcceptingAuthorizerStub implements Authorizer &#123; public Boolean authorize(String username, String password) &#123; return true; &#125;&#125; 它返回ture. 那就是. 为什么? 好的,假设你要测试你的系统的一部分其中需要你先登陆. 那我就登陆咯. 但你早已知道登陆是可行的,你在其他地方测试了它,为什么要测试多一次? 因为那样容易? 但是那样耗时,也需要做配置先. 如果登陆里有bug,那你的测试会失败.毕竟, 那是不必要的耦合. Hmmm,好吧,为了有效的辩论,当我同意吧,下一步应该? 你为了那测试,简单注入AcceptingAuthorizerStub到你的系统里. 它会毫无疑问地去授权用户. 对 所以如果我想测试没有授权过的用户时,我应该用一个返回false的stub. 又对了. Ok,那还有别的什么? 还有这个: 12345678public class AcceptingAuthorizerSpy implements Authorizer &#123; public boolean authorizeWasCalled = false; public Boolean authorize(String username, String password) &#123; authorizeWasCalled = true; return true; &#125;&#125; 我觉得那叫作Spy. 正确. 所以我为什么要这样用呢? 当你需要确定authorize方法一定会被系统调用的时候,你会这么做. 啊,我懂了.在我的测试里注入像一个stub的东西,但在测试的最后会检测变量authorizerWasCalled去确保系统是否真的调用了authorize方法. 完全正确. 所以一个Spy,侦查了调用者,我觉得它能记录所有这种类型的事情. 它的确能做到,例如,它能算出调用的总次数. yeah,或者它能保持一个列表来记录每次传入的参数. 对的,你可以通过Spies去了解,在测试的对象里的算法是如何工作的. 听起来像耦合. 那是!你不得不小心点. Spy用得越多,你的测试就越耦合你系统的实现,最终导致易脆的测试. 什么是易脆的测试? 一个测试破坏了一些不应该去破坏一个测试的理由. 如若你改变系统里的代码,某些测试也会受到破坏. 对,但设计良好的测试能最小化那种破坏,Spies恰恰与之相反. OK,我懂了.那还有别的测试替身么? 还有2种,第一种是: 123456789101112public class AcceptingAuthorizerVerificationMock implements Authorizer &#123; public boolean authorizeWasCalled = false; public Boolean authorize(String username, String password) &#123; authorizeWasCalled = true; return true; &#125; public boolean verify() &#123; return authorizedWasCalled; &#125;&#125; 当然,这是一个mock. 对,一个真正的Mock. 真正的? 对,这是一个正式的mock对象,与字面上的含义一致. 我明白了,它看起来像你把测试里的断言移至verify方法里,真正的mock. 对,Mocks知道他们在测试什么. 所以那是?你只是把断言放入mock里? 不完全,是,断言放入了mock里.然而,mock在测试的是行为. 行为? 对, mock并不关心函数返回的值.它关心的什么函数被调用,调用了什么参数,什么时候和有多频繁被调用. 所以一个mock经常是一个spy? 对,一个mock调查了被测试模块的行为,它知道什么样的行为是被期待的. Hmmm,把期望搬入mock里感觉上是一种耦合. 那是. 那为什么呢? 那样写一个mocking工具会容易的多. 一个mocking工具? 是的,像JMock,EasyMock,或Mockito等.那些工具能让你飞一般去创建mock对象. 看起来很复杂. 那倒不会,这里有Martin Fowler一篇介绍它的著名文章. 那是不是还有一本关于它的书,有么? 有,Growing Object Oriented Software, Guided by Tests就是一本关于驱动mock的主流设计哲学的书. Ok, 所以完了? 你说过还有另外一种的. 对, 再多一种, Fakes. 12345public class AcceptingAuthorizerFake implements Authorizer &#123; public Boolean authorize(String username, String password) &#123; return username.equals("Bob"); &#125; &#125; ok,那样很奇怪,所有叫做”Bob”的用户都会被授权. 对, 一个Fake有业务上的行为. 你可以驱动一个fake根据不同的数据表现出不同的行为. 看起来像虚拟器. 对,虚拟器是fakes. Fakes不是stubs吧? 不是,faker有真正业务上的行为;stubs没有. 事实上,我们之前谈论的测试替身没有一种包含真正业务行为. 所有fakes在基础概念上完全不同的. 的确是.我们可以这样说: 一个Mock是一种spy,一个spy是一种stub,而一个stub是一种dummy. 不是fake 不是它们中的任何一种. 它是完全不同类型的测试替身. 我可以想象fakes会复杂起来. 它们可以变得极端的复杂,所以它们会复杂到需要自己的单元测试.在极端情况下,fakes变成了真正的系统. Hmmm. 对,Hmmm. 我不常写fakes,事实上,三十多年来我没有写过一个. Wow! 那你会写什么? 其他剩下的测试替身么? 最多用的是stubs和spyies. 我自己写的,我不常用mocking工具. 那你用Dummies么? 对, 但极少. 那mocks呢? 只有我用mocking工具的时候用. 但你说过你不用mocking工具. 对,我通常不会用. 为什么不? 因为stubs 和 spies是很容易写的, 我的IDE让此变的简单.我只要指着接口告诉IDE去实现它,瞧!它就给我一个dummy了.所以我只需要一个小小改变就能变成stub 或spy.所以我真的很少用mocking工具. 所以它只是为了方便? 对, 事实上我不喜欢mocking工具的奇怪语法,还有配置它们的复杂性. 我发现写自己的测试替身在多数情况下会比较简单. OK, 好的, 谢谢你的对话. 随时欢迎. [1] xUnit Test Patterns PS: 最后,A生简单的介绍它们之间的关系:]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Time Of BigData]]></title>
    <url>%2F2014%2F10%2F01%2FTao-2014-2014-10-01-TimeOfBigData%2F</url>
    <content type="text"><![CDATA[大数据时代 大学的时候，老师曾提出一个简单的问题： 什么是IT？ 那个时候真的什么都不知道，就知道“挨踢” ：） IT全称是Information Technology，即信息技术。 在当代，多数技术人只知道关注T（技术）。 然而，在大数据时代，应该注重的是I（信息）本身。 这本《大数据时代》，打开了一道通往新时代的门，为此我们需要进行自我变革： (MindMapping Source) #思维变革 ##随机采样 小数据时代由于技术和人力问题，只能采样随机采样来采集数据。 用最少的数据获得最多的信息，时代局限使然。 随机采样的局限性： 分析的精确性随着采样的随机性增加而大幅提高，但与样本数量的增加关系不大。 所以，采样的随机性比数量更重要。 而且不适合考察子类别的情况，一旦继续细分，错误率就大大增加。 我们不能满足于正态分布一般中庸平凡的景象，生活中真正有趣的事情经常藏匿在细节之中。 采样分析却无法捕捉到这些细节。 ##样本=总体 一切都改变了，我们需要的是所有的数据，样本=总体。 无论是针对一个小团体还是整个社会，多样性是有额外的价值的。 “大数据”全在于发现和理解信息内容及信息之间的关系。 ##拥抱混乱 很多情况下，与其致力于避免错误相比，对错误的包容会带给我们更多的好处。 执迷于精确性是信息匮乏时代和模拟时代的产物。 只有5%的数据是结构化且适用于传统数据库的。 如果不接受混乱，剩下的95%的非结构化数据都无法利用。 大数据的简单算法比小数据的复杂算法更有效。 接受数据的不精确和不完美，反而能够更好的进行预测，也能够更好地了解这个世界。 混乱是一种标准途径，而不应该是竭力避免的。我们再也不能假装活在一个齐整的世界里。 ##因果只是关联的一种 在大数据时代，知道“是什么”就够了，没有必要知道“为什么”。 不必非得知道现象背后的原因，而是让数据自己“发声”。 在哲学界，关于因果关系是否存在的争论已持续几个世纪了。 如果凡事皆有因果，那么我们就没有决定的自由，即宿命论。 所有生命的轨迹都只是受因果关系的控制而已。 不是因果关系，而是相关关系。 相关关系的核心是量化两个数据值之间的数理关系。 我们理解世界不再需要建立在假设的基础上，这个假设是指针对现象建立的有关其产生机制和内在机理的假设。 一个东西要出故障，不会是瞬间的，而是慢慢地出问题的。 通过找到关联物并监控它，我们就能预测未来。 ##三个思维变革 实际上，与大数据相关的三个思维转变： 分析与某事物相关的所有数据，而不是依靠分析少量的数据样本。 接受数据的纷繁复杂，不再追求精确性。 不再探求难以捉摸的因果关系，转而关注事物的相关关系。 #商业变革 大数据发展的核心动力来源于人类测量、记录和分析世界的渴望。 ##数据化 数据化不是数字化，我们可以从文字，方位，沟通，甚至最不可能的地方提取数据。 世间万物，一切皆可“量化”。 有了大数据的帮助，我们不会把世界看做一连串自然或是社会现象的事件。 本质上世界是由信息构成的。 ##数据创新 数据就像一个神奇的宝石矿，第一眼只能看道冰山一角，不断挖掘才能不断给予。 对于数据，我们可以进行重组、扩展、开放和再利用。 就算是数据废气，数据折旧也可从中估值。 ##角色定位 根据价值的不同来源，分别出现三种大数据公司： 基于数据本身的公司 基于技能的公司 基于思维的公司 同时也出现了：新的职业： 数据科学家新的中介： 数据中间商 传统的专家也会逐渐消亡，全才会比专才更重要。大数据，决定企业竞争力。 #管理变革 ##风险 大数据会带来很多威胁： 加深对大众隐私的威胁：告知与许可，模糊/匿名化失效，隐私被二次利用。 对公平公正和自由意志的亵渎 ：运用预测来判断和惩罚人类的潜在行为。 运用不当会变成权贵依赖镇压民众的工具。 如果大数据分析完全准确，那么我们的未来就会被精准的预测。因此，我们不仅失去选择的权利，而且会按照预测去行动。如果预测成为了现实，我们也失去的自由的意志，自由选择生活的权利。 既然我们别无选择，那么我们也就不需要承担责任，这不是很讽刺吗？ 我们比想象中更容易受到数据的统治——让数据良莠参半的方式统治我们。反对数据独裁和对数据的过分依赖，才能走出大数据的困境。##掌控我们在生产和信息交流方式上的变革，必然会引发自我管理上的变革： 个人隐私保护从个人许可证到让数据使用者承担责任。 个人动因vs预测分析保护个人动因，防范“数据独裁”的危害： 公开、公正、可反驳原则。 击碎黑盒子大数据算法师的崛起：评估数据源，分析和预测工具的选取，计算结果的解读和考察。 反数据垄断大亨 #正在发生的未来 大数据为我们提供的不是最终答案，只是参考答案。 帮助是暂时的，更好的方法和答案还在不久的未来。 凡是过去，皆为序曲]]></content>
      <categories>
        <category>Tao</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Open Source Licence]]></title>
    <url>%2F2014%2F09%2F28%2FOther-2014-2014-09-28-OpenSourceLicence%2F</url>
    <content type="text"><![CDATA[开源许可证 开源世界的许可证多如牛毛，常见的开源许可证如BSD, GPL, LGPL,MIT等。 那么他们之间到底有什么区别呢？ 我尝试肤浅地解释他们之间的区别： 是否允许闭源？ 第一个分水岭，是否允许闭源？ 如果允许闭源的话，就可以修改源代码，拿来商用。 如果允许闭源，那下一个分支就是： 是否必须包括原版权？ Apache协议 允许闭源,但需在衍生的软件的协议里包括Apache的协议。 如果不需要放置原版权，是否可以在衍生的软件放入自己的广告又成了下一个分支: MIT最为宽松,可以放入广告， BSD则不能。 如果不允许闭源，那下一个分支就是： 是否采用同样的许可证？ 对新增的代码是否需要采用源代码同样的许可证。 GPL最为严格,要求所有衍生代码采用同样的许可证. LGPL则不需要。 WTFPL 然而,最牛逼开源协议当属 WTFPL (what the fuck public license) ，没有之一。]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MindMapping - Choice on Tools]]></title>
    <url>%2F2014%2F09%2F25%2FTech-2014-2014-09-25-MindMapping-ChoiceOnTools%2F</url>
    <content type="text"><![CDATA[MindMapping - 工具的选择 从中学的时候接触一本叫《学习的革命》的书开始，学会了用思维导图来分析问题和记录笔记。 而我用来制作思维导图的工具，也一直在变化。 工具的变化，其实反映的是我思维方式的变化。 纸笔 通过纸和笔，可以无阻力的制作思维导图。 适合临时性的创作，不适合需要反复修改的情形。 优点不会被工具所限制，思维无阻 缺点难以携带和分享 手机：App 手机的App就非常方便随身携带，但是屏幕太小，思维阻力最大。 优点随时随地记录思维，易携带和分享 缺点屏幕有限，思维阻力大 PC Website 通过在线的网站来制作简单，但是受限于网络环境。 网速不好的时候，思维阻力也大。 优点无需客户端，打开网页即可，便于分享 缺点受限制于网络环境，思维阻力大 PC Client：FreeMind/Xmind 通过PC客户端（FreeMind/Xmind）来制作就不会受限于网速，相对思维阻力较小。 但是其格式一般基于XML or 其他格式，可读性差，对版本控制不友好。 优点不受限于网络环境，思维阻力小 缺点难以版本控制，分享不方便 最终方案： Org text 经过了种种工具的试用，我最终找到了适合自己的工具。 Emacs下的Org模式，基于纯文本，版本控制和可读性最好。 对版本控制也很友好，还可以导出MM格式来由FreeMind/Xmind来进行优化。 唯一复杂的就是中间多了一层，有利必有弊嘛。 优点纯文本格式，版本控制友好 制作简单，思维阻力最小。 可导出MM格式，通过第三方美化 缺点多了一层中间层，略复杂]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Way of Philosophy - Metaphysics]]></title>
    <url>%2F2014%2F09%2F21%2FTao-2014-2014-09-21-WayOfPhilosophy-Metaphysics%2F</url>
    <content type="text"><![CDATA[哲学之路 : 形而上学 作为一支奇葩，中学时代最感兴趣的科目就是哲学。 严格意义上是指政治课里的辩证唯物法，后来还想通过自考来考取哲学学位， 不过最后因买不到考试用的教材而放弃了（冷门到没钱赚，哈哈）。 直到看了林欣浩《哲学家们都干了些什么？》，我才决定从头学习大师的著作来追求我的哲学之路。 #第一站: 形而上学 古希腊作为哲学的起源,出现了好多哲学的圣人. 苏格拉底就是其中的佼佼者,他的学生柏拉图也是非常著名的. 而柏拉图的学生亚里士多德,提出了《形而上学》. 形而上者谓之道形而上者谓之道,形而下者谓之器. ——《易经·系辞》 这里的形而上学主要是指哲学，同样形而上的还有数学和物理学（都是思辨科学）。 哲学在先，数学和物理学是哲学的分支。 数学研究事物的共同原理，物理学研究事物的偶性。 性质与范围 哲学是关于事物最初本原和原因的科学，属于思辨科学。 研究“作为存在的存在”，以及其应有的各种偶性。 本体学说 只有本体是主体，其他的一切属性都是载体。 本体是可以分离的，可独立存在。 四因学说 本因（质料因），物因（形式因），动因（运动因），极因（目的因）。 事物的形成需要一定的质料，区别与其他事物的本质就是形式因。 事物的生灭变化需要一种最初的力量源泉，即运动因。 任何事物都有一定的目的。 形式和质料学说 形式因，运动因，目的因归结在一起总称为“形式”。 形式与质料是事物的两个方面。 潜能和现实学说 质料是没有任何规定性的不确定的东西，只是一种潜在的可能。 当质料与形式结合起来，形式给予它一定的性质，才称为现实。 一 “一”的含义有2种： 其一，就偶性而言的一。 其二，就自身而言的一。 我想起了“一即全，全即一” 总结 总得来说，这本书概念性的东西太多。 按照我目前的智商水平也就一知半解，余额不足需要充值。 ：） 不是因为懂才写下来，是因为不懂才写下来。]]></content>
      <categories>
        <category>Tao</category>
      </categories>
      <tags>
        <tag>Philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weird Issue - Line NotFound]]></title>
    <url>%2F2014%2F09%2F18%2FArt-2014-2014-09-18-WeridIssue-NotFoundedLine%2F</url>
    <content type="text"><![CDATA[疑难杂症 : 找不到的线 #找不到的线 ##起因 在最近的工作中，遇到一个简单地不能再简单的需求，把图片里的一条横线改个颜色。 拥有多年PS（涂鸦）经验的老夫以为可以秒杀这个需求，万万没想到，竟花费了我几天的时间才搞定。 ##分析 按照常识，那条横线一般都会是一张图片，找到源文件PS一下就搞定。 但是，当我查看放图片的目录时就震惊了，木有！！ ##困境 这时我就下意识地觉得这条简单的横线可能是用js+css绘制的，瞬间觉得原作者高大上起来。 可是在查看了所有的js和css代码之后，我陷入了深深的绝望之中。木有，还是木有！！！ ##排除 在我陷入困境几天之后，好心的同事S提醒我试试排除法。 于是经过一轮HTML的注释之后，我找到的Root Cause！ ##解决 1&lt;body background="bg.png"&gt; 放大图片一看,焕然大悟!! 原来还是图片,不过是用一条很长的竖线里一个很猥琐的点,去平铺而成的横线!! Orz #总结 ##答案总在不经意的时候逃过 1.有些问题的确不容易一下找到答案,往往解决方案就在附近却视而不见。 2.人往往容易往复杂的地方去想，蓦然回首却发现答案很简单。 3.实在不行的时候，试试排除法吧。囧 ##吐糟 最后吐槽下这个设计，这样高明（猥琐）的设计往往带来维护的复杂性。 很多时候，还是Keep it simple 比较好。]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>TroubleShoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap - Way Of Responsive Web Design]]></title>
    <url>%2F2014%2F09%2F06%2FTech-2014-2014-09-06-Bootstrap-WayOfResponsiveWebDesign%2F</url>
    <content type="text"><![CDATA[Bootstrap - 响应式Web设计之道建立自己的个人blog也有一段时间的，跟用其他著名的blog不一样。所有事情都可以享受DIY的乐趣，当然，也有付出不少的时间。基本功能也搞的7788， 就是用手机端查看博客的时候，排版差劲的很。基于后PC时代，移动设备的时代也开始了。稍微百谷歌度之后，还是有简单的解决方案的——Bootstrap。 什么是 Bootstrap？应用w3cschool的定义:Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。 Bootstrap 的网格系统（Grid System）Grid System是基于移动设备优先策略,简单实现多设备自适应layout的关键。通过不同的class设定就能实现不同的布局： e.g. 以下HTML Code，就能简单地实现响应式布局 123456789&lt;div class="container-fluid"&gt;&lt;div class="row"&gt; &lt;div class="col-xs-12 col-md-offset-1"&gt; &lt;br&gt; content &lt;br&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; Bootstrap 的必要文件除了Bootstrap自己的CSS和字体,Jquery的库也是要的,官方下载后放入自己的路径下即可 最终效果如下,不同设备下不同的自适应布局:大屏幕 中屏幕 小屏幕]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Issues On Upgrade Jekyll-2.2.0]]></title>
    <url>%2F2014%2F09%2F03%2FTech-2014-2014-09-03-IssuesOnUpgradeJekyll-2-2-0%2F</url>
    <content type="text"><![CDATA[Jekyll-2.2.0 的坑手痒把Jekyll升级到2.2.0的时候,发现服务已经启动不起来了. @_@ ||| 折腾了一阵子,搞定了中间出现的几个问题, 终于正常了. ^_^ 问题1 : JavaScript runtime IssueCould not find a JavaScript runtime. Jekyll 2.2.0比起旧版本需要多一个Js runtime, 装个node.js fixed. 1sudo apt-get install nodejs 问题2: pygments IssueDeprecation: The ‘pygments’ configuration option has been renamed to ‘highlighter’. Please update your config file accordingly. The allowed values are ‘rouge’, ‘pygments’ or null. pygments (代码高亮插件)在 _config.yml的配置格式改变了. 1pygments: true --&gt; highlighter: pygments 最后重新启动下服务,搞定! jekyll serve --watch]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Benefit of Extract Method]]></title>
    <url>%2F2014%2F09%2F02%2FTech-2014-2014-09-02-BenefitOfExtractMethod%2F</url>
    <content type="text"><![CDATA[提炼方法的好处？ 在最近的一次Code Review里，我和同事在一个基本的问题上产生了分歧。三言两语很难说的清楚，我决定尝试把它写清楚。 分歧的起因在于我把以下的这段代码： 12345678// some methodmemset( pData-&gt;field1 , ' ' ,sizeof(pData-&gt;field1));memset( pData-&gt;field2 , ' ' ,sizeof(pData-&gt;field2));memset( pData-&gt;field3 , ' ' ,sizeof(pData-&gt;field3));memset( pData-&gt;field4 , ' ' ,sizeof(pData-&gt;field4));memset( pData-&gt;field5 , ' ' ,sizeof(pData-&gt;field5));memset( pData-&gt;field6 , ' ' ,sizeof(pData-&gt;field6));... 写成: 12345678910111213void Init_String(CHAR *str)&#123; memset(str ,' ',sizeof(str))&#125;// some methodInit_String(pData-&gt;field1);Init_String(pData-&gt;field2);Init_String(pData-&gt;field3);Init_String(pData-&gt;field4);Init_String(pData-&gt;field5);Init_String(pData-&gt;field6);... 同事对此有以下几点疑问:1. 有什么好处? 2. 多了个方法，性能会变低。 3. 与过去的风格不同，增加学习曲线。 动机在回答所有的问题之前,我先说下我的动机,在原先的方法里 1memset( pData-&gt;field1 , ' ' ,sizeof(pData-&gt;field1)); 看来好简单的一句程序里，出现了2次”pData-&gt;field1”。这里已经出现了重复的臭味道，随着这样的写法数量增多，这段代码就越来越臭了。 有代码洁癖的我是觉得难以忍受的。 根据DRY原则（Dont Repeat Yourself）,我把代码里不变的部分用Extract Method的手法重构到一个方法里。 方法名叫Init_String（），我简单的把一个内存的操作的工作封装到‘初始化字符串’的方法里。 下次我再看到这里我就只需要知道它能帮我初始化‘字符串’就行，而不需要分神去理会它是如何的实现。 然后，我再来一一解答所有问题： 有什么好处?1. 符合DRY原则 (一次且仅一次) 去除重复的代码,消除坏味道. 2. 符合OCP原则 (开闭原则） 拆分不变与变化的代码，对于扩展是开放的，但是对于修改是封闭的. 3. 更整洁的代码 (Clean Code) 多了个方法，性能会变低?多了一个新方法,每次memset时就call 多次 Init_String（）.看上去是会多耗点性能,但是新的method跟原来的代码是在同一个文件里的.从内存的角度,其内存地址也应该相近,在数量有限的call里,我认为性能是人感受不出来的.当然要更深入讨论,可以去了解C函数的调用机制. 与过去的风格不同，增加学习曲线。的确,这里是个问题。例如100个文件里就1个文件是这种写法，风格不统一会对新人造成一点点阅读困难。 我们当然做不到一夜之间就改变所有文件，也没有这个必要。这不应该成为阻止我们改进的绊脚石。我一直认为改进应该是增量的，每一次随着需求变化可以适当在满足需求的同时，改善现有的代码。 重构是有成本的，但也是有回报的。我觉得值得投资。 Extract Method最后再啰嗦下什么是Extract Method （提炼函数）. Extract Method （提炼函数）是最常用的重构手法之一。当看见一个过长的函数或者一段需要注释才能让人理解用途的代码，就应该将这段代码放进一个独立函数中。 简短而命名良好的函数的好处：首先，如果每个函数的粒度都很小，那么函数被复用的机会就更大；其次，这会使高层函数读起来就想一系列注释；再次，如果函数都是细粒度，那么函数的覆写也会更容易些。 Further Read Referencememset 一次且仅一次 开闭原则 代码重构]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WhatBuddhaSay?]]></title>
    <url>%2F2014%2F08%2F26%2FTao-2014-2014-08-26-WhatBuddhaSay%2F</url>
    <content type="text"><![CDATA[《佛祖都说了些什么》 《佛祖都说了些什么》这本算佛教的入门书，对我这种想系统地了解下佛教的人来说，还是不错的。 佛教有两大基本原理：万法缘起（哲学）、轮回（神学）。 我个人比较buy哲学角度的万法缘起，对于轮回就。。很多理念了解起来还是挺有意思的，如三千世界。同时也介绍了各个学派以及主要的代表人物。 两大原理 学派 主要代表人物 MindMapping Source (Org Format):123456789101112131415161718192021222324252627282930313233343536373839* 两大原理** 万法缘起 （哲学） 万事万物都是因为一定的原因产生的*** 因缘 因是内因，缘是外因*** 法无自性，万法无常**** 无常 事物处于一直变化的状态中，不能永恒存在。**** 无我 我也是无常，有生有灭*** 凡人执著心**** 法执 认为万物实有**** 我执 认为我实有*** 空 事物的本质，就是佛性**** 色即是空**** 破除时间与空间概念** 轮回 （神学）*** 六道轮回 一切皆苦，六道既苦海*** 因果报应 菩萨畏因，众生畏果。**** 业 众生所做的事**** 报 （果） 业按照因缘规律产生的后果***** 三报 现报，生报，后报*** 涅磐 跳出轮回**** 修行方法***** 戒 遵守戒律***** 定 打坐禅定***** 慧 （最重要） 开启智慧，不再无明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273* 学派** 大乘 （万法性空） 主张普度众生，帮助他人修行 人人都能成佛，领悟佛性即可。*** 中观学 中观般若，类似辩证唯物主义，般若学的高峰。 （般若，梵语“智慧”。 ） **** 假有 事物存在，但不远存不变。**** 八不中道 不生亦不灭，不常亦不断。 不一亦不异，不来亦不出。**** 真俗二谛义 真谛，真正的真理，是不能用语言直接表达。 俗谛， 世俗的道理。 *** 唯识学 瑜伽唯识，类似主观唯心主义**** 六识（六根） 眼，耳，鼻，舌，身，意 **** 末那识 （第七） 产生我的概念 **** 阿赖耶识 （第八） 其他7识都是无明，造业的结果，本质是空的。 破除七识就能成佛。***** ..主体 众生的，轮回的.***** 共相 众人阿赖耶识共同作用**** 赖耶缘起 阿赖耶识产生万物*** 天台宗**** 三千世界 一念三千***** 十界互具 十如是***** 三世间 一念三世**** 佛是“性具善恶” 但不为之所控制**** 无情有性 所有物体都有佛性**** 三谛圆融 （空 假 中） 因缘所生法，我说即是空，亦为是假名，亦是中道义。*** 华严宗**** 一即一切，一切即一**** 一真法界 万物是互为因果的一体**** 法界缘起 以不起为起*** 禅宗**** 饥来吃饭，困来即眠**** 反对文字、理性**** 即心即佛*** 净土宗**** 往生净土 《往生咒》**** 注重佛号*** 密宗**** 灌顶**** 修炼方法 身密、口密、意密** 小乘 （万法实有）*** 只讲自己修行*** 普通人不能成佛*** 不持金银*** 类型**** 佛***** 阿尼陀佛**** 菩萨 （大乘） 建立净土***** 观世音***** 弥勒佛**** 罗汉 1234567891011121314151617181920212223242526* 主要代表人物** 释迦牟尼 ** 龙树 （中观）*** 人法两空*** 八不中道** 道安*** 不依国主，法事难立*** 反对格义*** 出家** 慧远 （道安徒弟）*** 三报论*** 不敬王者*** 形尽神不灭** 鸠摩罗什*** 翻译佛经** 道生*** 顿悟成佛*** 善不受报*** 一阐提也能成佛** 玄奘 （唯识）*** 求取《瑜伽师地论》*** 一阐提不能成佛** 慧能 （南禅，禅宗创始人）*** 本来无一物，何处惹尘埃*** 反对坐禅、依赖佛经** 神秀 （北禅）]]></content>
      <categories>
        <category>Tao</category>
      </categories>
      <tags>
        <tag>Buddha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Why DDD?]]></title>
    <url>%2F2014%2F08%2F24%2FArt-2014-2014-08-24-IDDD%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 为什么DDD？ 《领域驱动设计 : 软件核心复杂性应对之道》（DDD）于06年出版的时候，经过8年时间的演化，DDD也开始添加一些新的内容，《实现领域驱动设计》（IDDD）正是对其做了很好的补充。 作为一个OO思维的工程师，我觉得对OO的领悟分为三个阶段： 一、开始使用面向对象 摆脱面向过程的思维影响，用更自然的角度去思考问题。 面向对象，用类和接口去封装对象的行为。 二、开始使用设计模式 模式一词来自亚历山大的《建筑的永恒之道》，使用模式是为了得到无名之质。 由Gof引入到软件行业，于是有了著名的《设计模式》一书。 设计模式进一步去除设计上的重复，着重解决一些经典的问题。 三、开始使用领域设计 领域概念的出现，是为了把业务从其他非业务（技术实现）的泥团之中分离出来。 把所有跟业务有关的知识封装于领域之内,实现业务与实现的解耦。 从而避免出现贫血对象，避免业务逻辑四分八裂在系统之中，与页面和数据库深深的耦合在一起。 IDDD对DDD进行了很好的补充： 增加了领域事件的概念，也增加了实际应用中会遇到的问题和解决方案。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。 章节内容:一 : DDD入门二 : 领域、子域和限界上下文三 : 上下文映射图四 : 架构五: 实体六: 值对象七: 领域服务八: 领域事件九: 模块十: 聚合十一: 工厂十二: 资源库十三: 集成限界上下文十四: 应用程序]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 14 Application]]></title>
    <url>%2F2014%2F08%2F19%2FArt-2014-2014-08-19-IDDD-14%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 十四: 应用程序应用程序通过用户界面向外展示领域模型的概念，并允许用户在模型上执行各种操作。 MindMapping Source (Org Format):123456789101112131415161718192021222324252627282930313233* 应用程序 应用程序通过用户界面向外展示领域模型的概念，并允许用户在模型上执行各种操作。** 用户界面*** 类型**** Web界面***** Web 1.0 纯粹请求-应答式，Struts，Spring MVC，ASP.net等。***** Web 2.0 富互联网应用，使用Ajax和DHTML， eg：Google GWT，Ext JS，Adobe Flex，MS Silverlight等。**** 本地客户端GUI Java Swing，WinForm，WPF等。*** 渲染**** ..领域对象***** 使用调停者模式解耦**** ..数据传输对象 渲染多个聚合实例**** 领域负载对象.. 整个聚合实例的引用**** 处理不同的客户端***** RIA***** 图像界面***** REST服务***** 消息系统**** 渲染适配器 处理用户编辑** 应用服务*** 解耦服务输出 六边形架构** 基础设施 为应用程序的其他部分提供技术支持。*** 使用依赖倒置原则解耦]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 13 Integrate Bounded Context]]></title>
    <url>%2F2014%2F08%2F18%2FArt-2014-2014-08-18-IDDD-13%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 十三: 集成限界上下文在上下文映射图中，多个限界上下文之间需要进行集成。 MindMapping Source (Org Format):1234567891011121314151617181920212223242526272829303132* 集成限界上下文 在上下文映射图中，多个限界上下文之间需要进行集成。** 集成基础*** 分布式计算原则 与RPC有着根本性区别**** 网络是不可靠的**** 总会存在时间延迟，有时非常严重**** 带宽是有限的**** 不要假设网络是安全的**** 网络拓扑结构将发生变化**** 知识和政策在多个管理员之间传播**** 网络传输是有成本的**** 网络是异构的*** 跨系统边界交换信息**** 创建某种形式的消息契约***** XML***** JSON***** 特殊格式***** 发布语言** 集成类型*** 通过REST**** 服务器端--开放主机服务**** 客户端--防腐层实现*** 通过消息**** 事件驱动架构**** 长时间处理过程***** 消息幂等***** 状态机***** 超时跟踪器**** 当消息机制或系统不可用时 考虑最差后果，以及对策]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>IDDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 12 Repository]]></title>
    <url>%2F2014%2F08%2F15%2FArt-2014-2014-08-15-IDDD-12%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 十二: 资源库资源库表示一个安全的存储区域，对其存品起保护作用。 负责对象生命周期的中后期。 MindMapping Source (Org Format):1234567891011121314151617181920212223242526* 资源库 表示一个安全的存储区域，对其存品起保护作用。 负责对象生命周期的中后期。** 面向..资源库*** 集合 模拟一个Set集合，不容许多次添加同一个聚合实例。 隐式跟踪每个持久化对象的改变。**** Hibernate实现**** TopLink实现*** 持久化 不支持对象变化的跟踪。**** Coherence实现**** MongoDB实现** 额外的行为 特殊的查找方法，返回值对象的查询结果。** 管理事务*** 针对关系型数据库，把事务放在应用层。*** 不要过度使用，特别在并发的环境下。** 类型层级*** Liskov替换原则** vs. 数据访问对象（DAO）*** DAO是从数据库的角度来看待问题*** Repository是从对象的角度来看待问题** 测试*** 以内存实现进行测试]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>IDDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 11 Factory]]></title>
    <url>%2F2014%2F08%2F04%2FArt-2014-2014-08-04-IDDD-11%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 十一: 工厂最经典的设计模式之一，负责复杂对象和聚合的创建，对象生命周期的前期. MindMapping Source (Org Format):1234567891011121314151617* 工厂 最经典的设计模式之一，负责复杂对象和聚合的创建，对象生命周期的前期。** 领域模型中的工厂*** 只需要创建对象，不需要承担领域模型中的其他职责。** 聚合根中的工厂方法*** 有效表达限界上下文中的通用语言*** 减轻客户端创建实例时的负担*** 确保所创建的实例处于正确的状态** 领域服务中的工厂*** 集成**** 限界上下文**** 防腐层**** 发布语言**** 开发主机服务*** 与其他限界上下文交互*** 将外部对象翻译成本地对象]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>IDDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 10 Aggregate]]></title>
    <url>%2F2014%2F08%2F01%2FArt-2014-2014-08-01-IDDD-10%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 十: 聚合聚合由实体和值对象在一致性边界内组成，却是最不容易理解的。 MindMapping Source (Org Format):12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* 聚合** 原则*** 在一致性边界内建模真正的不变条件**** 不变的业务规则**** 事务一致性**** 一致性边界*** 设计小聚合**** 更好性能和伸缩性**** 根实体 Root Entity*** 通过唯一标识引用其他聚合**** 通过标识引用使多个聚合协调工作**** 建模对象导航性***** 失联领域模型 （Disconnected Domain Model）****** 资源库****** 领域服务***** 通过应用服务来处理依赖关系**** 不在同个事务中修改多个聚合实例*** 在边界之外使用最终一致性**** 由边界内来控制一致性 — — 事务一致性**** 由边界外来控制一致性 — — 最终一致性** 打破原则的理由 有很多因素需要我们做出妥协，但不应该找各种借口来打破原则。*** 方便用户界面*** 缺乏技术支持*** 全局事务*** 查询性能** 通过发现，深入理解*** 重新思考设计*** 估算聚合成本*** 常用用例场景*** 内存消耗*** 探索另外的设计*** 实现最终一致性** 实现*** 创建具有唯一标识的根实体 将实体建模成聚合根（Aggregate Root）*** 优先使用值对象*** 迪米特法则和“告诉非询问”原则**** Law of Dememter***** “最小知识”原则***** 任何对象的任何方法只能调用****** 自身****** 传入的参数对象****** 它所创建的对象****** 自身包含的其他对象，并且拥有直接访问权**** Tell, Dont Ask***** 一个对象不应该被告知该怎么做*** 乐观并发**** 为根实体创建版本号**** 合理控制版本号*** 避免依赖注入**** 在聚合内注入 资源库/领域服务 有害，可在应用服务中使用]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>IDDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 8 DomainEvent]]></title>
    <url>%2F2014%2F07%2F31%2FArt-2014-2014-07-31-IDDD-8%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 八: 领域事件用于捕获发生在领域内，领域专家所关心的一些事情 MindMapping Source (Org Format):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* 领域事件 用于捕获发生在领域内，领域专家所关心的一些事情** 何时/为什么使用？*** 当。。。的时候。。*** 通用语言的正式成员** 建模*** 创建具有聚合特征的**** 发生在过去的事情**** 应设计成不变的，但拥有唯一标识*** 身份标识**** 方便比较**** 需要发布在外部限界上下文时，唯一标识是必要的** 发布*** 从领域模型中发布**** 观察者模式***** 发送方 由聚合创建，并发布出去***** 订阅方 由应用/领域服务，向领域事件注册订阅 与聚合位于相同线程内*** 向远程限界上下文发布**** 消息设施的一致性 最终一致性***** 领域模型和消息设施，共享持久化存储***** 领域模型的持久化存储和消息持久化存储，由全局XA事务（两段提交）所控制***** 领域模型的持久化存储中，创建特殊的存储区域，即事件存储**** 自治服务和系统***** 通过领域事件，将任何系统设计成自治服务和系统***** 避免远程过程调用（RPC）**** 容许时延 长时间的事件延迟有可能发生** 事件存储*** 作为消息队列使用，将所有领域事件发布出去*** 基于REST的事件通知*** 跟踪bug*** 业务分析和预测*** 重建聚合*** 撤销操作** (向外部)转发存储事件的架构风格*** 发布事件通知**** 以REST资源的方式***** “拉”的方式，非“推”的方式***** 不能很好支持有顺序的接收**** 通过消息中间件** 实现*** 发布NotifiactionLog*** 发布基于消息的事件通知**** 事件消重***** 幂等操作 进行多次重复操作和只进行一次操作所产生的结果相同.]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 9 Module]]></title>
    <url>%2F2014%2F07%2F31%2FArt-2014-2014-07-31-IDDD-9%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 九: 模块模块是命名的容器，通用语言的重要组成部分。 MindMapping Source (Org Format):12345678910111213141516171819202122232425262728293031* 模块** Module*** Java**** package*** C#**** namespace*** Ruby**** module** 通过模块完成设计*** 命名的容器*** 通用语言的重要组成部分*** 设计规则**** 和领域概念协调一致**** 根据通用语言来命名模块**** 不要机械式根据组件类型来创建 eg 所有领域服务放在一起**** 松耦合**** 杜绝循环依赖**** 父子模块放松原则**** 不是静态概念，与模型的对象一道进行建模** 模块的基本命名规范*** 层级形式命名*** 避免顶级模块名与第三方模块命名冲突** 领域模型的命名规范*** 加入限界上下文名*** *.domain.model** 其他层的模块*** 分层架构命名*** 需要时才划分子模块** 先考虑模块，再考虑上下文]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>IDDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 7 DomainService]]></title>
    <url>%2F2014%2F07%2F27%2FArt-2014-2014-07-27-IDDD-7%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 七: 领域服务领域服务是用于处理业务逻辑，无状态的操作。 确定是否需要使用，不要滥用，滥用导致贫血模型。 MindMapping Source (Org Format):123456789101112131415161718192021* 领域服务** 什么是？*** 无状态的操作*** 处理业务逻辑** 什么不是？*** 不是应用服务 SOA，RPC，MoM** 确定是否需要？ 不要滥用，滥用导致贫血模型** 建模*** 独立接口有必要？ 没有，不会有另外的实现类的时候不必要*** 一个计算过程 业务逻辑绝不放在应用层*** 转换服务 用于集成限界上下文*** 创建迷你层 取决领域模型特征*** 测试 从客户端角度]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 6 ValueObject]]></title>
    <url>%2F2014%2F07%2F27%2FArt-2014-2014-07-27-IDDD-6%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 六: 值对象值对象易于开发、测试和维护。 尽量使用值对象来建模，而不是实体。 MindMapping Source:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* 值对象** 特征*** 度量或描述 度量或描述领域中的一件东西*** 不变性**** 只读，创建后不改变**** 只通过构造函数赋值*** 概念整体**** 整体值对象 （Whole Value aka Value Object）*** 可替换性*** 相等性*** 无副作用行为**** 无副作用函数 （Side-Effect-Free Function)** 最小化集成*** 更少的职责假设** 表示标准类型*** Java里可用枚举来表示** 测试*** TDD** 实现*** 2个构造函数**** 1.接受所有参数的**** 2.浅复制其他值对象的 （Shallow Copy）** 持久化*** 拒绝数据建模泄露**** 数据建模式次要的 根据领域模型来设计数据模型， 而不是根据数据模型来设计领域模型*** 与ORM**** 单个值对象***** 直接映射**** 保存多个值对象***** 序列化到单个列****** 缺点******* 列宽限制 MySQL Varchar limit ：65535******* 不能查询 其内在属性不能作为SQl查询条件******* 需自定义类型***** 使用数据库实体****** 缺点******* 对象-关系抗阻***** 使用联合表****** 缺点******* 需满足数据库范式******* 每一个属性都不应该为NULL******* 不能包含嵌套的集合**** 枚举状态对象]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 5 Entity]]></title>
    <url>%2F2014%2F07%2F26%2FArt-2014-2014-07-26-IDDD-5%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 五: 实体实体是有着生命周期的领域对象，拥有唯一标识。 MindMapping Source:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* 实体** 为什么使用？*** 唯一的身份标识*** 生命周期（可变性，状态变化）** 唯一标识*** 生成方式（从简单到复杂）**** 用户提供***** 用户手动输入复杂性：在于需要用户自己生成高质量的标识**** 应用程序生成***** UUIDUniversally Unique Identifier***** GUIDGlobally Unique Identifier**** 持久化机制生成***** DB 自增列机制**** 另一个限界上下文提供*** 标识生成时间**** 对象创建时**** 持久化对象时*** 委派标识**** 层超类型Layer Supertype*** 标识稳定性**** 确保标识不被修改** 发现实体*** 本质特征*** 关键行为*** 角色和职责**** 领域对象扮演多种角色***** 通常用接口来定义****** 隐藏细节**** 领域语言优于技术实现*** 创建实体**** 提供构造函数来初始化实体状态*** 验证**** 目的***** 检查模型正确性**** 验证属性***** 自封装（Self-Encapsulation）**** 验证整体***** 规格Specification***** 策略模式（Strategy）***** 延迟验证 （Deferred Validation）**** 验证对象组合*** 跟踪变化**** 领域事件**** 事件存储]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 4 Architecture]]></title>
    <url>%2F2014%2F07%2F23%2FArt-2014-2014-07-23-IDDD-4%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 四 : 架构第四章内容丰富，有些骨头有待反复嚼啃。 六边形架构的确很赞，新项目开始架构首选。 MindMapping Source:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135* 架构不需要特定的架构，选择架构是为了减少风险，而不增加风险。** 分层Layers Architecture*** 严格Strict Layers Architecture*** 松散Relaxed Layers Architecture**** 允许耦合***** 观察者Observer***** 调停者Mediator*** 依赖倒置原则（DIP）Dependency Inversion Principle **** 抽象不应该依赖细节**** 细节应该依赖抽象** 六边形架构Hexagonal Architecture, 端口与适配器*** 特点**** 对称平等,持久生命力**** 非前后端,而是内外区域**** 一个客户一个适配器*** 基础架构**** 支撑其他架构(SOA,REST,CQRS...)** SOA面向服务架构(Service-Oriented Architecture)*** 服务设计原则**** 契约通过契约文档,阐述自身的目的和功能.**** 松耦合依赖最小化**** 抽象只发布契约,隐藏内部逻辑**** 重用性可被其他服务重用**** 自治性自行控制环境与资源，以保持独立性**** 无状态性**** 可发现性可通过元数据来查找和理解**** 组合性** RESTRepresentational State Transfer*** Web架构风格的一种**** 松耦合性**** 伸缩性*** RESTful HTTP**** 服务器***** 资源是关键概念每种资源拥有一个URI****** 与客户端交互格式******* XML******* JSON******* HMTL******* 二进制数据***** 无状态通信****** 不同请求互相独立****** 提高系统伸缩性***** 可看做对象****** 对象方法******* GET******* PUT******* POST******* DELETE**** 客户端***** 转移方式****** 超媒体HATEOAS : Hypermedia as the Engine of Application State****** 服务器重定向*** 和DDD联合方法**** 为系统接口层单独创建限界上下文通过适当的策略来访问实际的核心模型***** 优先考虑***** 适合专属系统**** 使用标准媒体类型***** 使用通用格式e.g. ical***** 本质：共享内核/发布语言***** 适合通用系统** CQRS命令和查询职责分离 ： Comman-Query Responsiblity Segregation*** 读写分离**** 读模型 （查询模型）***** 数据库视图（可实现）**** 写模型 （命令模型）***** 每个方法完成时发布领域事件****** 不合法的命令将失败，不发布领域事件***** 事件发布器***** 事件订阅器****** 更新查询模型******* 同步******* 异步***** ETLORM持久化机制可用数据仓库的ETL转换结果*** 客户端驱动命令处理**** 客户端向服务器发送命令**** 命令处理器（接收）只完成有限的功能***** 分类风格categorized style****** 根据命令类别来实现应用服务****** 简单：易理解、创建、维护***** 专属风格dedicated style****** 每种命令对应单独的类****** 职责单一、互相独立***** 消息风格messaging style ，专属风格进一步发展****** 每个命令通过异步消息发送异步提高伸缩性****** 最复杂*** 处理最终一致性的查询模型**** UI临时性显示先前提交给命令模型的参数**** 显式地在UI上显示当前查询模型的时间** EDA 事件驱动架构*** 管道与过滤器*** 长时间处理过程（也叫Saga）**** 需考虑时间敏感性***** 被动超时检查***** 主动超时检查**** 最终一致性*** 事件源**** 事件存储***** 快照** 数据网织和基于网格的分布式计算*** 数据复制**** 内存数据库*** 事件驱动网织**** 支持开放架构*** 持续查询*** 分布式处理]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 3 Context Map]]></title>
    <url>%2F2014%2F07%2F20%2FArt-2014-2014-07-20-IDDD-3%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 三 : 上下文映射图见过太多大泥球了，最后不得不另谋他路。 MindMapping Source:12345678910111213141516171819202122232425262728293031323334353637383940414243* 上下文映射图** 为什么重要?*** 反映出与"大泥团"之间的集成关系*** 从解决方案空间的角度看待问题** 绘制*** [Brandolini]风格*** U/D**** 上游(Upstream)**** 下游(Downstream)*** 不是企业架构** 产品和组织关系*** 合作关系Partnership*** 共享内核 Shared Kernel*** 客户方-供应方开发Customer-Supplier Development*** 尊奉者Conformist*** 另谋他路Separate Way*** 大泥球Big Ball Of Mud*** 防腐层(ACL)Anticorruption Layer**** 领域服务Domain Service*** 开放主机服务(OHS)Open Host Service**** REST*** 发布语言(PL)Published Language**** REST***** XML***** JSON**** EDA事件驱动架构(Event-Driven Architecture) ***** 领域事件Domain Event***** 最终一致性Eventual Consistency]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 2 Domian,Subdomain and Bounded Context]]></title>
    <url>%2F2014%2F07%2F20%2FArt-2014-2014-07-20-IDDD-2%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 二 : 领域、子域和限界上下文 MindMapping Source:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* 领域、子域和限界上下文** 领域（一个组织所做的事情以及其中所包含的一切）*** （即）核心域**** 关注点** 子域*** 模块** 限界上下文*** 上下文映射图*** 理解**** 显式边界***** “大而全”注定失败***** 上下文才是王道**** 充满语义**** 不仅仅只包括模型***** DB Schema***** UI****** 拒绝使用智能UI反模式（Smart UI Anti-Pattern）**** 大小标准***** 如音乐完整性、纯洁性、力量、优雅、美***** 陷阱****** 根据开发任务拆分限界上下文****** 为了架构或资源创建****** 急于小型化**** 与技术组件保持一致***** IDE****** Eclipse/IntelliJ IDEA******* Project****** VS.NET******* Solution***** Java****** Top Package Name****** JAR/WAR/EAR******* OSGi******* Jigsaw***** .Net****** DLL** 战略设计*** 为什么重要？**** 更广阔的视野**** 避免大泥球架构（Big Ball of Mud）** 现实中的领域和子域*** 问题空间（Problem Space）**** 核心域和其他子域的组合*** 解决方案空间（Solution Space）**** 一组特定的软件模型**** 包括一个或多限界上下文通常希望和子域一对一]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDDD 1 Introduce]]></title>
    <url>%2F2014%2F07%2F18%2FArt-2014-2014-07-18-IDDD-1%2F</url>
    <content type="text"><![CDATA[&lt;&lt; 实现领域驱动设计 &gt;&gt; 一 : DDD入门 看了才知道，原来一直处于初级阶段 DDD-Lite。 MindMapping Source:1234567891011121314151617181920212223242526272829* DDD入门** 为什么需要*** 难以捉摸的业务价值*** 处理领域复杂性**** 简化,非复杂化*** 贫血症和失忆症**** 贫血领域对象(Anemic Domain Object)***** 缺少内在行为***** 设计不当造成** 如何DDD*** 通用语言**** 团队共享的语言**** 通用,不是万能限界内通用*** 限界上下文** 业务价值*** 有用的领域模型*** 更准确的业务定义*** 领域专家可参与设计*** 更好的用户体验*** 清晰的模型边界*** 更好的企业架构*** 敏捷,迭代和持续建模*** 使用战略和战术新工具** 挑战*** 花时间和精力:创建通用语言*** "艰难"的寻找:领域专家*** 改变思考方式]]></content>
      <categories>
        <category>Art</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About Naming]]></title>
    <url>%2F2014%2F07%2F06%2FArt-2014-2014-07-06-Naming%2F</url>
    <content type="text"><![CDATA[命名那些事命名的方式基本有三种，驼峰式、蛇式、匈牙利命名法。 其中使用驼峰和蛇式居多，而匈牙利命名法这种方法实在是反人类。 这里引用2位大师的吐槽 Robert C. Martin: … nowadays HN and other forms of type encoding are simply impediments. They make it harder to change the name or type of a variable, function, member or class. They make it harder to read the code. And they create the possibility that the encoding system will mislead the reader. Linus Torvalds : Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged—the compiler knows the types anyway and can check those, and it only confuses the programmer. 在变量前面加入类型前缀这种做法没有任何帮助,只能让代码难以阅读,让大脑受伤.编译器知道类型检测,无需画蛇添足. MindMapping Source:123456789* Naming** Camel(驼峰式)*** lowerCamel(小驼峰)*** UpperCamel(大驼峰) 也叫Pascal (帕斯卡)** Snake(蛇式)*** snake_case** Hungarian(匈牙利)*** c_Hungarian]]></content>
      <categories>
        <category>Art</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[14 Years of XP]]></title>
    <url>%2F2014%2F06%2F29%2FTech-2014-2014-06-29-14Years-Of-XP%2F</url>
    <content type="text"><![CDATA[14 Years of XPBob大叔近来发表了一篇文章《极限编程，一次反思》（译），总结了极限编程（XP，Extreme Programming）这14年来的变化以及发展。 回想我第一次听到XP，已经是10几年前的事情。那时候我还在读大学，刚加入学校的计算机协会，认识了一个编程多年的同学，他介绍我去看下Kent Beck的XP。我当时就想，极限编程，这么花哨的名字肯定不是什么好东西，我还是认真学好我的软件工程好过。直到我出来工作几年，慢慢的接触其中的内容，才发现当时的我是多么的纱布。 所以，当你对有一件事情有偏见的时候，就应该小心地提醒自己，是否被偏见蒙蔽的了自己，最好debug一下自己。 :) 1234567891011121314151617181920* XP** Simple Design** The Planning Game*** Scrum*** Kanban** Testing*** TDD**** ATDD**** BDD** Small Releases*** Continues Delivery** Refactoring** Metaphor*** DDD** Pair Programming** Collective Ownership** 40 Hour Week*** Sustainable Rate** Coding Standards** On Site Customer]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Start Change]]></title>
    <url>%2F2014%2F06%2F17%2FOther-2014-2014-06-17-StartChange%2F</url>
    <content type="text"><![CDATA[Start Change0617: New Blog start on github]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
</search>
